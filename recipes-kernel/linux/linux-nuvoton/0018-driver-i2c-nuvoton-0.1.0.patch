From fb67cfa8205256081d1ec137cb9ba9fa603f1df7 Mon Sep 17 00:00:00 2001
From: Joseph Liu <kwliu@nuvoton.com>
Date: Mon, 23 Sep 2019 19:32:55 +0800
Subject: [PATCH] driver: i2c: nuvoton: 0.1.0

Signed-off-by: Joseph Liu <kwliu@nuvoton.com>
---
 drivers/i2c/busses/i2c-npcm7xx.c | 2243 ++++++++++++++++++------------
 1 file changed, 1356 insertions(+), 887 deletions(-)

diff --git a/drivers/i2c/busses/i2c-npcm7xx.c b/drivers/i2c/busses/i2c-npcm7xx.c
index 6d177d3f0e0b..3418ee049294 100644
--- a/drivers/i2c/busses/i2c-npcm7xx.c
+++ b/drivers/i2c/busses/i2c-npcm7xx.c
@@ -7,7 +7,6 @@
 #include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/clk/nuvoton.h>
-#include <linux/crc8.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
@@ -18,8 +17,9 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
+#include <linux/jiffies.h>
 
-#define I2C_VERSION "0.0.3"
+#define I2C_VERSION "0.1.0"
 
 enum smb_mode {
 	SMB_SLAVE = 1,
@@ -38,13 +38,10 @@ enum smb_state_ind {
 	SMB_SLAVE_RESTART_IND = 4,
 	SMB_SLAVE_DONE_IND = 5,
 	SMB_MASTER_DONE_IND = 6,
-	SMB_NO_DATA_IND = 7,
 	SMB_NACK_IND = 8,
 	SMB_BUS_ERR_IND = 9,
 	SMB_WAKE_UP_IND = 10,
-	SMB_MASTER_PEC_ERR_IND = 11,
 	SMB_BLOCK_BYTES_ERR_IND = 12,
-	SMB_SLAVE_PEC_ERR_IND = 13,
 	SMB_SLAVE_RCV_MISSING_DATA_IND = 14,
 };
 
@@ -68,11 +65,10 @@ enum smb_state {
 	SMB_MASTER_START,
 	SMB_SLAVE_MATCH,
 	SMB_OPER_STARTED,
-	SMB_REPEATED_START,
 	SMB_STOP_PENDING
 };
 
-// Module supports setting multiple own slave addresses:
+// Module supports setting multiple own slave addresses
 enum smb_addr {
 	SMB_SLAVE_ADDR1 = 0,
 	SMB_SLAVE_ADDR2,
@@ -93,8 +89,6 @@ static struct regmap *gcr_regmap;
 static struct regmap *clk_regmap;
 
 #define NPCM_I2CSEGCTL  0xE4
-#define NPCM_SECCNT	0x68
-#define NPCM_CNTR25M	0x6C
 #define I2CSEGCTL_VAL	0x0333F000
 
 // Common regs
@@ -120,7 +114,7 @@ static struct regmap *clk_regmap;
 #define NPCM_SMBADDR6			0x016
 #define NPCM_SMBADDR10			0x017
 
-// SMBADDR array: because the addr regs are sprincled all over the address space
+// SMBADDR array: because the addr regs are sprinkled all over the address space
 const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 			       NPCM_SMBADDR4, NPCM_SMBADDR5, NPCM_SMBADDR6,
 			       NPCM_SMBADDR7, NPCM_SMBADDR8, NPCM_SMBADDR9,
@@ -133,7 +127,7 @@ const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBSCLHT			0x01E // SCL High Time
 
 // BANK 1 regs
-#define NPCM_SMBFIF_CTS			0x010 // FIFO Control
+#define NPCM_SMBFIF_CTS			0x010 // Both FIFOs Control and status
 #define NPCM_SMBTXF_CTL			0x012 // Tx-FIFO Control
 #define NPCM_SMBT_OUT			0x014 // Bus T.O.
 #define NPCM_SMBPEC			0x016 // PEC Data
@@ -175,7 +169,7 @@ const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBCTL1_RWS_FIELDS	  (NPCM_SMBCTL1_START | NPCM_SMBCTL1_STOP | \
 				   NPCM_SMBCTL1_ACK)
 // NPCM_SMBADDR reg fields
-#define NPCM_SMBADDR_ADDR		GENMASK(6, 0)
+#define NPCM_SMBADDR_A			GENMASK(6, 0)
 #define NPCM_SMBADDR_SAEN		BIT(7)
 
 // NPCM_SMBCTL2 reg fields
@@ -221,11 +215,7 @@ const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBFIF_CTS_SLVRSTR		BIT(7)
 
 // NPCM_SMBTXF_CTL reg fields
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_CTL_TX_THR		GENMASK(5, 0)
-#else
 #define NPCM_SMBTXF_CTL_TX_THR		GENMASK(4, 0)
-#endif
 #define NPCM_SMBTXF_CTL_THR_TXIE	BIT(6)
 
 // NPCM_SMBT_OUT reg fields
@@ -234,39 +224,22 @@ const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBT_OUT_T_OUTST		BIT(7)
 
 // NPCM_SMBTXF_STS reg fields
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_STS_TX_BYTES	GENMASK(5, 0)
-#else
 #define NPCM_SMBTXF_STS_TX_BYTES	GENMASK(4, 0)
-#endif
 #define NPCM_SMBTXF_STS_TX_THST		BIT(6)
 
 // NPCM_SMBRXF_STS reg fields
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_STS_RX_BYTES	GENMASK(5, 0)
-#else
 #define NPCM_SMBRXF_STS_RX_BYTES	GENMASK(4, 0)
-#endif
 #define NPCM_SMBRXF_STS_RX_THST		BIT(6)
 
 // NPCM_SMBFIF_CTL reg fields
 #define NPCM_SMBFIF_CTL_FIFO_EN		BIT(4)
 
 // NPCM_SMBRXF_CTL reg fields
-// Note: on the next HW version of this module, this HW is about to switch to
-//	 32 bytes FIFO. This size will be set using a config.
-//	 on current version 16 bytes FIFO is set using a define
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_CTL_RX_THR		GENMASK(5, 0)
-#define NPCM_SMBRXF_CTL_THR_RXIE	BIT(6)
-#define NPCM_SMBRXF_CTL_LAST_PEC	BIT(7)
-#define SMBUS_FIFO_SIZE			32
-#else
 #define NPCM_SMBRXF_CTL_RX_THR		GENMASK(4, 0)
 #define NPCM_SMBRXF_CTL_LAST_PEC	BIT(5)
 #define NPCM_SMBRXF_CTL_THR_RXIE	BIT(6)
+
 #define SMBUS_FIFO_SIZE			16
-#endif
 
 // SMB_VER reg fields
 #define SMB_VER_VERSION			GENMASK(6, 0)
@@ -275,8 +248,8 @@ const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 // stall/stuck timeout
 const unsigned int DEFAULT_STALL_COUNT =	25;
 
-// Data abort timeout
-const unsigned int ABORT_TIMEOUT =	 1000;
+// retries in a loop for master abort
+const unsigned int RETRIES_NUM =	10000;
 
 // SMBus spec. values in KHZ
 const unsigned int SMBUS_FREQ_MIN = 10;
@@ -293,28 +266,33 @@ const unsigned int SCLFRQ_MAX = 511;
 #define SCLFRQ_0_TO_6		GENMASK(6, 0)
 #define SCLFRQ_7_TO_8		GENMASK(8, 7)
 
-// SMB Maximum Retry Trials (on Bus Arbitration Loss)
-const unsigned int SMB_RETRY_MAX_COUNT = 2;
 const unsigned int SMB_NUM_OF_ADDR = 10;
 
-// for logging:
 #define NPCM_I2C_EVENT_START	BIT(0)
 #define NPCM_I2C_EVENT_STOP	BIT(1)
 #define NPCM_I2C_EVENT_ABORT	BIT(2)
 #define NPCM_I2C_EVENT_WRITE	BIT(3)
+
 #define NPCM_I2C_EVENT_READ	BIT(4)
 #define NPCM_I2C_EVENT_BER	BIT(5)
 #define NPCM_I2C_EVENT_NACK	BIT(6)
 #define NPCM_I2C_EVENT_TO	BIT(7)
+
 #define NPCM_I2C_EVENT_EOB	BIT(8)
+#define NPCM_I2C_EVENT_STALL	BIT(9)
+#define NPCM_I2C_EVENT_CB	BIT(10)
+#define NPCM_I2C_EVENT_DONE	BIT(11)
 
-#define NPCM_I2C_EVENT_LOG(event)   (bus->event_log |= event)
+#define NPCM_I2C_EVENT_READ1	BIT(12)
+#define NPCM_I2C_EVENT_READ2	BIT(13)
+#define NPCM_I2C_EVENT_READ3	BIT(14)
+#define NPCM_I2C_EVENT_READ4	BIT(15)
 
-#define SMB_RECOVERY_SUPPORT
+#define NPCM_I2C_EVENT_NMATCH_SLV	BIT(16)
+#define NPCM_I2C_EVENT_NMATCH_MSTR	BIT(17)
+#define NPCM_I2C_EVENT_BER_SLV		BIT(18)
 
-// slave mode: if end device reads more data than available, ask issuer or
-// request for more data:
-#define SMB_WRAP_AROUND_BUFFER
+#define NPCM_I2C_EVENT_LOG(event)	(bus->event_log |= event)
 
 // Status of one SMBus module
 struct npcm_i2c {
@@ -329,6 +307,7 @@ struct npcm_i2c {
 	int			msgs_num;
 	int			num;
 	u32			apb_clk;
+	struct i2c_bus_recovery_info rinfo;
 	enum smb_state		state;
 	enum smb_oper		operation;
 	enum smb_mode		master_or_slave;
@@ -341,193 +320,80 @@ struct npcm_i2c {
 	u16			wr_size;
 	u16			wr_ind;
 	bool			fifo_use;
-	u8			threshold_fifo;
 
 	// PEC bit mask per slave address.
 	//		1: use PEC for this address,
 	//		0: do not use PEC for this address
 	u16			PEC_mask;
 	bool			PEC_use;
-	u8			crc_data;
 	bool			read_block_use;
-	u8			retry_count;
 	u8			int_cnt;
 	u32			event_log;
+	u32			event_log_prev;
 	u32			clk_period_us;
-	u32			int_time_stamp[2];
+	unsigned long		int_time_stamp;
+	unsigned long		bus_freq; // in kHz
+	u32			xmits;
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	u8			own_slave_addr;
+	struct i2c_client	*slave;
+
+	// currently I2C slave IF only supports single byte operations.
+	// in order to utilyze the npcm HW FIFO, the driver will ask for 16bytes
+	// at a time, pack them in buffer, and then transmit them all together
+	// to the FIFO and onward to the bus .
+	// NACK on read will be once reached to bus->adap->quirks->max_read_len
+	// sending a NACK whever the backend requests for it is not supported.
+
+	// This module can be master and slave at the same time. separate ptrs
+	// and counters:
+	int			slv_rd_size;
+	int			slv_rd_ind;
+	int			slv_wr_size;
+	int			slv_wr_ind;
+	u8			slv_rd_buf[SMBUS_FIFO_SIZE];
+	u8			slv_wr_buf[SMBUS_FIFO_SIZE];
+#endif
 };
 
-static inline void _npcm7xx_get_time_stamp(u32 *time_quad0, u32 *time_quad1)
-{
-	u32 seconds, seconds_last;
-	u32 ref_clock;
-
-	regmap_read(clk_regmap, NPCM_SECCNT, &seconds_last);
-
-	do {
-		regmap_read(clk_regmap, NPCM_SECCNT, &seconds);
-		regmap_read(clk_regmap, NPCM_CNTR25M, &ref_clock);
-		regmap_read(clk_regmap, NPCM_SECCNT, &seconds_last);
-	} while (seconds_last != seconds);
-
-	*time_quad0 = ref_clock;
-	*time_quad1 = seconds;
-}
-
-#define EXT_CLOCK_FREQUENCY_MHZ 25
-#define CNTR25M_ACCURECY	EXT_CLOCK_FREQUENCY_MHZ  // minimum accurecy
-
-// Function:	 _npcm7xx_delay_relative
-// Parameters:
-//		 us_delay -  number of microseconds to delay since t0_time.
-//				  if zero: no delay.
-//
-//		t0_time	      - start time , to measure time from.
-// get a time stamp, delay us_delay from it. If us_delay has already passed
-// since the time stamp , then no delay is executed. returns the time elapsed
-// since t0_time
-
-static inline u32 _npcm7xx_delay_relative(u32 us_delay, u32 t0_time0,
-					  u32 t0_time1)
-{
-	u32 t1_time_0, t1_time_1;
-	u32 time_elapsed;
-	u32 minimum_delay = (us_delay * EXT_CLOCK_FREQUENCY_MHZ)
-		+ CNTR25M_ACCURECY;
-
-	// this is equivalent to microSec/0.64 + minimal tic length.
-	do {
-		_npcm7xx_get_time_stamp(&t1_time_0, &t1_time_1);
-		time_elapsed = ((EXT_CLOCK_FREQUENCY_MHZ * 1000000) *
-				(t1_time_1 - t0_time1)) +
-				(t1_time_0 - t0_time0);
-	} while (time_elapsed < minimum_delay);
-
-	// return elapsed time
-	return (u32)(time_elapsed / EXT_CLOCK_FREQUENCY_MHZ);
-}
-
 static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
 					enum smb_bank bank)
 {
-	if (bus->fifo_use)
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_BNK_SEL) |
-			 FIELD_PREP(SMBCTL3_BNK_SEL, bank),
+	if (bank == SMB_BANK_0)
+		iowrite8(ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_BNK_SEL,
+			 bus->reg + NPCM_SMBCTL3);
+	else
+		iowrite8(ioread8(bus->reg + NPCM_SMBCTL3) | SMBCTL3_BNK_SEL,
 			 bus->reg + NPCM_SMBCTL3);
 }
 
-DECLARE_CRC8_TABLE(npcm7xx_crc8);
-
-static u8 npcm_smb_calc_crc8(u8 crc_data, u8 data)
-{
-	crc_data = crc8(npcm7xx_crc8, &data, 1, crc_data);
-	return crc_data;
-}
-
-static void npcm_smb_calc_PEC(struct npcm_i2c *bus, u8 data)
+static void npcm_smb_init_params(struct npcm_i2c *bus)
 {
-	if (bus->PEC_use)
-		bus->crc_data = npcm_smb_calc_crc8(bus->crc_data, data);
+	bus->stop_ind = SMB_NO_STATUS_IND;
+	bus->rd_size = 0;
+	bus->wr_size = 0;
+	bus->rd_ind = 0;
+	bus->wr_ind = 0;
+	bus->int_cnt = 0;
+	bus->event_log_prev = bus->event_log;
+	bus->event_log = 0;
+	bus->read_block_use = false;
+	bus->int_time_stamp = 0;
+	bus->PEC_use = false;
+	bus->PEC_mask = 0;
+	if (bus->slave)
+		bus->master_or_slave = SMB_SLAVE;
 }
 
 static inline void npcm_smb_wr_byte(struct npcm_i2c *bus, u8 data)
 {
 	iowrite8(data, bus->reg + NPCM_SMBSDA);
-	npcm_smb_calc_PEC(bus, data);
 }
 
 static inline void npcm_smb_rd_byte(struct npcm_i2c *bus, u8 *data)
 {
 	*data = ioread8(bus->reg + NPCM_SMBSDA);
-	npcm_smb_calc_PEC(bus, *data);
-}
-
-static inline u8 npcm_smb_get_PEC(struct npcm_i2c *bus)
-{
-	if (bus->PEC_use)
-		return bus->crc_data;
-	else
-		return 0;
-}
-
-static inline void npcm_smb_write_PEC(struct npcm_i2c *bus)
-{
-	if (bus->PEC_use) {
-		// get PAC value and write to the bus:
-		npcm_smb_wr_byte(bus, npcm_smb_get_PEC(bus));
-	}
-}
-
-//
-//  NPCM7XX SMB module allows writing to SCL and SDA pins directly
-//  without the need to change muxing of pins.
-//  This feature will be used for recovery sequences i.e.
-//
-static void npcm_smb_set_SCL(struct i2c_adapter *_adap, int level)
-{
-#ifdef SMB_CAPABILITY_FORCE_SCL_SDA
-	unsigned long flags;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
-
-	// Select Bank 0 to access NPCM_SMBCTL4
-	spin_lock_irqsave(&bus->lock, flags);
-	npcm_smb_select_bank(bus, SMB_BANK_0);
-
-	// Set SCL_LVL, SDA_LVL bits as Read/Write (R/W)
-	iowrite8(ioread8(bus->reg + NPCM_SMBCTL4) | SMBCTL4_LVL_WE,
-		 bus->reg + NPCM_SMBCTL4);
-
-	// Set level
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3)
-		& ~SMBCTL3_SCL_LVL) | FIELD_PREP(SMBCTL3_SCL_LVL,
-		level), bus->reg + NPCM_SMBCTL3);
-
-	// Set SCL_LVL, SDA_LVL bits as Read Only (RO)
-	iowrite8(ioread8(bus->reg + NPCM_SMBCTL4)
-		 & ~SMBCTL4_LVL_WE, bus->reg + NPCM_SMBCTL4);
-
-	// Return to Bank 1
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	spin_unlock_irqrestore(&bus->lock, flags);
-#endif
-}
-
-static int npcm_smb_get_SCL(struct i2c_adapter *_adap)
-{
-	unsigned long flags;
-	unsigned int ret = 0;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
-
-	// Select Bank 0 to access NPCM_SMBCTL4
-	spin_lock_irqsave(&bus->lock, flags);
-	npcm_smb_select_bank(bus, SMB_BANK_0);
-
-	// Get SCL level
-	ret = FIELD_GET(SMBCTL3_SCL_LVL,  ioread8(bus->reg + NPCM_SMBCTL3));
-
-	// Return to Bank 1
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	spin_unlock_irqrestore(&bus->lock, flags);
-	return ret;
-}
-
-static int npcm_smb_get_SDA(struct i2c_adapter *_adap)
-{
-	unsigned long flags;
-	unsigned int ret = 0;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
-
-	// Select Bank 0 to access NPCM_SMBCTL4
-	spin_lock_irqsave(&bus->lock, flags);
-	npcm_smb_select_bank(bus, SMB_BANK_0);
-
-	// Get SDA level
-	ret = FIELD_GET(SMBCTL3_SDA_LVL,  ioread8(bus->reg + NPCM_SMBCTL3));
-
-	// Return to Bank 1
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	spin_unlock_irqrestore(&bus->lock, flags);
-	return ret;
 }
 
 static inline u16 npcm_smb_get_index(struct npcm_i2c *bus)
@@ -542,7 +408,7 @@ static inline u16 npcm_smb_get_index(struct npcm_i2c *bus)
 	return index;
 }
 
-// quick protocol:
+// quick protocol (just address):
 static inline bool npcm_smb_is_quick(struct npcm_i2c *bus)
 {
 	if (bus->wr_size == 0 && bus->rd_size == 0)
@@ -557,18 +423,16 @@ static void npcm_smb_disable(struct npcm_i2c *bus)
 	// select bank 0 for SMB addresses
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
-	// Slave Addresses Removal
+	// Slave addresses removal
 	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++)
 		iowrite8(0, bus->reg + NPCM_SMBADDR[i]);
 
-	// select bank 0 for SMB addresses
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
 	// Disable module.
 	iowrite8(ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_ENABLE,
 		 bus->reg + NPCM_SMBCTL2);
 
-	// Set module disable
 	bus->state = SMB_DISABLE;
 }
 
@@ -576,11 +440,43 @@ static void npcm_smb_enable(struct npcm_i2c *bus)
 {
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2) | SMBCTL2_ENABLE),
 		 bus->reg + NPCM_SMBCTL2);
+
+	bus->state = SMB_IDLE;
+}
+
+static bool npcm_smb_wait_for_bus_free(struct npcm_i2c *bus, bool may_sleep)
+{
+	int cnt = 0;
+	int max_count = 2; /* wait for 2 ms */
+
+	if (may_sleep)
+		might_sleep();
+	else
+		max_count = max_count * 100; /* since each delay is 10 us */
+
+	while  (ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BUSY) {
+		if (cnt < max_count) {
+			if (may_sleep)
+				msleep_interruptible(1);
+			else
+				udelay(10);
+			cnt++;
+
+		} else {
+			bus->cmd_err = -EAGAIN;
+			return false;
+		}
+	}
+	return true;
 }
 
 // enable\disable end of busy (EOB) interrupt
 static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
 {
+	// Clear EO_BUSY pending bit:
+	iowrite8(ioread8(bus->reg + NPCM_SMBCST3) | NPCM_SMBCST3_EO_BUSY,
+		 bus->reg + NPCM_SMBCST3);
+
 	if (enable) {
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
 			 NPCM_SMBCTL1_EOBINTE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
@@ -589,41 +485,51 @@ static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
 		iowrite8(ioread8(bus->reg + NPCM_SMBCTL1) &
 			 ~NPCM_SMBCTL1_EOBINTE & ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
-
-		// Clear EO_BUSY pending bit:
-		iowrite8(ioread8(bus->reg + NPCM_SMBCST3) |
-			 NPCM_SMBCST3_EO_BUSY, bus->reg + NPCM_SMBCST3);
 	}
 }
 
-static inline bool npcm_smb_tx_fifo_full(struct npcm_i2c *bus)
+static inline bool npcm_smb_tx_fifo_empty(struct npcm_i2c *bus)
 {
-	// check if TX FIFO full:
-	return (bool)FIELD_GET(NPCM_SMBTXF_STS_TX_THST,
-			       ioread8(bus->reg + NPCM_SMBTXF_STS));
+	u8 tx_fifo_sts = ioread8(bus->reg + NPCM_SMBTXF_STS);
+
+	// check if TX FIFO is not empty
+	if ((tx_fifo_sts & NPCM_SMBTXF_STS_TX_BYTES) == 0)
+		return false;
+
+	// check if TX FIFO status bit is set:
+	return (bool)FIELD_GET(NPCM_SMBTXF_STS_TX_THST, tx_fifo_sts);
 }
 
 static inline bool npcm_smb_rx_fifo_full(struct npcm_i2c *bus)
 {
-	// check if RX FIFO full:
-	return (bool)FIELD_GET(NPCM_SMBRXF_STS_RX_THST,
-			       ioread8(bus->reg + NPCM_SMBRXF_STS));
+	u8 rx_fifo_sts = ioread8(bus->reg + NPCM_SMBRXF_STS);
+
+	// check if RX FIFO is not empty:
+	if ((rx_fifo_sts & NPCM_SMBRXF_STS_RX_BYTES) == 0)
+		return false;
+
+	// check if rx fifo full status is set:
+	return (bool)FIELD_GET(NPCM_SMBRXF_STS_RX_THST, rx_fifo_sts);
+}
+
+static inline void npcm_smb_clear_fifo_int(struct npcm_i2c *bus)
+{
+	iowrite8((ioread8(bus->reg + NPCM_SMBFIF_CTS) &
+			NPCM_SMBFIF_CTS_SLVRSTR) |
+			NPCM_SMBFIF_CTS_RXF_TXE,
+			bus->reg + NPCM_SMBFIF_CTS);
 }
 
 static inline void npcm_smb_clear_tx_fifo(struct npcm_i2c *bus)
 {
-	// clear TX FIFO:
-	iowrite8(ioread8(bus->reg + NPCM_SMBTXF_STS) |
-		 NPCM_SMBTXF_STS_TX_THST,
+	iowrite8(ioread8(bus->reg + NPCM_SMBTXF_STS) | NPCM_SMBTXF_STS_TX_THST,
 		 bus->reg + NPCM_SMBTXF_STS);
 }
 
 static inline void npcm_smb_clear_rx_fifo(struct npcm_i2c *bus)
 {
-	// clear RX FIFO:
-	iowrite8(ioread8(bus->reg + NPCM_SMBRXF_STS) |
-			 NPCM_SMBRXF_STS_RX_THST,
-			 bus->reg + NPCM_SMBRXF_STS);
+	iowrite8(ioread8(bus->reg + NPCM_SMBRXF_STS) | NPCM_SMBRXF_STS_RX_THST,
+		 bus->reg + NPCM_SMBRXF_STS);
 }
 
 static void npcm_smb_int_enable(struct npcm_i2c *bus, bool enable)
@@ -654,8 +560,7 @@ static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
 	// override HW issue: SMBus may fail to supply stop condition in Master
 	// Write operation.
 	// Need to delay at least 5 us from the last int, before issueing a stop
-	_npcm7xx_delay_relative(5, bus->int_time_stamp[0],
-				bus->int_time_stamp[1]);
+	udelay(10);
 
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_STOP) &
 		 ~(NPCM_SMBCTL1_START | NPCM_SMBCTL1_ACK),
@@ -669,42 +574,12 @@ static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
 		else
 			npcm_smb_clear_tx_fifo(bus);
 
-		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTS) |
-				 NPCM_SMBFIF_CTS_SLVRSTR |
-				 NPCM_SMBFIF_CTS_RXF_TXE,
-				 bus->reg + NPCM_SMBFIF_CTS);
+		npcm_smb_clear_fifo_int(bus);
 
 		iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
 	}
 }
 
-static inline void npcm_smb_abort_data(struct npcm_i2c *bus)
-{
-	unsigned int timeout = ABORT_TIMEOUT;
-	u8 data;
-
-	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_ABORT);
-	// Generate a STOP condition
-	npcm_smb_master_stop(bus);
-	npcm_smb_rd_byte(bus, &data);
-
-	// Clear NEGACK, STASTR and BER bits
-	iowrite8(NPCM_SMBST_STASTR | NPCM_SMBST_NEGACK |
-		NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-
-	// Wait till STOP condition is generated
-	while (FIELD_GET(NPCM_SMBCTL1_STOP, ioread8(bus->reg + NPCM_SMBCTL1))) {
-		timeout--;
-		if (!FIELD_GET(NPCM_SMBCTL1_STOP,
-			       ioread8(bus->reg + NPCM_SMBCTL1)))
-			break;
-		if (timeout <= 1) {
-			dev_err(bus->dev, "%s, abort timeout!\n", __func__);
-			break;
-		}
-	}
-}
-
 static inline void npcm_smb_stall_after_start(struct npcm_i2c *bus, bool stall)
 {
 	if (stall)
@@ -719,23 +594,22 @@ static inline void npcm_smb_stall_after_start(struct npcm_i2c *bus, bool stall)
 
 static inline void npcm_smb_nack(struct npcm_i2c *bus)
 {
-	if (bus->rd_ind < (bus->rd_size - 1))
-		dev_info(bus->dev,
-			 "\tNACK err bus%d, SA=0x%x, rd(%d\%d), op=%d st=%d\n",
-			 bus->num, bus->dest_addr, bus->rd_ind, bus->rd_size,
-			 bus->operation, bus->state);
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_ACK) &
 		 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_START),
 		 bus->reg + NPCM_SMBCTL1);
 }
 
+static int  npcm_smb_slave_enable_l(struct npcm_i2c *bus,
+				    enum smb_addr addr_type, u8 addr,
+				    bool enable);
+
 static void npcm_smb_reset(struct npcm_i2c *bus)
 {
 	// Save NPCM_SMBCTL1 relevant bits. It is being cleared when the
 	// module is disabled
-	u8 smbctl1 = ioread8(bus->reg + NPCM_SMBCTL1) & (NPCM_SMBCTL1_GCMEN
-						      | NPCM_SMBCTL1_INTEN
-						      | NPCM_SMBCTL1_NMINTE);
+	u8 smbctl1;
+
+	smbctl1 = ioread8(bus->reg + NPCM_SMBCTL1);
 
 	// Disable the SMB module
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_ENABLE),
@@ -747,15 +621,25 @@ static void npcm_smb_reset(struct npcm_i2c *bus)
 	// Restore NPCM_SMBCTL1 status
 	iowrite8(smbctl1 & ~NPCM_SMBCTL1_RWS_FIELDS, bus->reg + NPCM_SMBCTL1);
 
-	// Reset driver status
+	// Clear BB (BUS BUSY) bit
+	iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
+
+	iowrite8(0xFF, bus->reg + NPCM_SMBST);
+
+	// Clear EOB bit
+	iowrite8(NPCM_SMBCST3_EO_BUSY, bus->reg + NPCM_SMBCST3);
+
+	// Clear all fifo bits:
+	iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO, bus->reg + NPCM_SMBFIF_CTS);
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	if (bus->slave) {
+		npcm_smb_slave_enable_l(bus, SMB_SLAVE_ADDR1, bus->slave->addr,
+					true);
+	}
+#endif
+
 	bus->state = SMB_IDLE;
-	//
-	// Configure FIFO disabled mode so slave will not use fifo
-	//  (master will set it on if supported)
-	iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) &
-		~NPCM_SMBFIF_CTL_FIFO_EN,
-		bus->reg + NPCM_SMBFIF_CTL);
-	bus->fifo_use = false;
 }
 
 static inline bool npcm_smb_is_master(struct npcm_i2c *bus)
@@ -764,85 +648,65 @@ static inline bool npcm_smb_is_master(struct npcm_i2c *bus)
 			       ioread8(bus->reg + NPCM_SMBST));
 }
 
-static int npcm_smb_master_abort(struct npcm_i2c *bus)
-{
-	int ret = -(EIO);
-
-	// Only current master is allowed to issue Stop Condition
-	if (npcm_smb_is_master(bus)) {
-		npcm_smb_abort_data(bus);
-		ret = 0;
-	}
-
-	npcm_smb_reset(bus);
-
-	return ret;
-}
-
 static void npcm_smb_callback(struct npcm_i2c *bus,
 			      enum smb_state_ind op_status, u16 info)
 {
 	struct i2c_msg *msgs = bus->msgs;
 	int msgs_num = bus->msgs_num;
 
+	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_CB);
+
+	if (!msgs)
+		return;
+
+	if (completion_done(&bus->cmd_complete) == true)
+		return;
+
 	switch (op_status) {
 	case SMB_MASTER_DONE_IND:
-	// Master transaction finished and all transmit bytes were sent
-	// info: number of bytes actually received after the Master
-	//	receive operation (if Master didn't issue receive it
-	//	should be 0)
-	// Notify that not all data was received on Master or Slave
-	// info:
-	//	on receive: number of actual bytes received
-	//	when PEC is used even if 'info' is the expected number
-	//	of bytes, it means that PEC error occurred.
-	{
-		if (msgs[0].flags & I2C_M_RD)
-			msgs[0].len = info;
-		else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
-			msgs[1].len = info;
-
-		bus->cmd_err = 0;
-		complete(&bus->cmd_complete);
-	}
-	break;
+		bus->cmd_err = bus->msgs_num;
+		// fall through:
+	case SMB_BLOCK_BYTES_ERR_IND:
+		// Master transaction finished and all transmit bytes were sent
+		if (bus->msgs) {
+			if (msgs[0].flags & I2C_M_RD)
+				msgs[0].len = info;
+			else if (msgs_num == 2 &&
+				 msgs[1].flags & I2C_M_RD)
+				msgs[1].len = info;
+		}
 
-	case SMB_NO_DATA_IND:
-	// Notify that not all data was received on Master or Slave
-	// info:
-	//on receive: number of actual bytes received
-	//	when PEC is used even if 'info' is the expected number
-	//	of bytes,it means that PEC error occurred.
-	{
-		if (msgs[0].flags & I2C_M_RD)
-			msgs[0].len = info;
-		else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
-			msgs[1].len = info;
-
-		bus->cmd_err = -EFAULT;
-		complete(&bus->cmd_complete);
-	}
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
+
+		if (completion_done(&bus->cmd_complete) == false)
+			complete(&bus->cmd_complete);
 	break;
+
 	case SMB_NACK_IND:
-		// MASTER transmit got a NAK before transmitting all bytes
+		// MASTER transmit got a NACK before tx all bytes
 		// info: number of transmitted bytes
-		bus->cmd_err = -EAGAIN;
-		complete(&bus->cmd_complete);
+		bus->cmd_err = -ENXIO;
+		if (bus->master_or_slave == SMB_MASTER)
+			complete(&bus->cmd_complete);
 
 		break;
 	case SMB_BUS_ERR_IND:
 		// Bus error
-		// info: has no meaning
-		bus->cmd_err = -EIO;
-		complete(&bus->cmd_complete);
+		bus->cmd_err = -EAGAIN;
+		if (bus->master_or_slave == SMB_MASTER)
+			complete(&bus->cmd_complete);
+
 		break;
 	case SMB_WAKE_UP_IND:
 		// SMBus wake up
-		// info: has no meaning
 		break;
 	default:
 		break;
 	}
+
+	bus->operation = SMB_NO_OPER;
+	if (bus->slave)
+		bus->master_or_slave = SMB_SLAVE;
 }
 
 static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
@@ -856,53 +720,58 @@ static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
 	return 0;
 }
 
-static void npcm_smb_write_to_fifo(struct npcm_i2c *bus, u16 max_bytes_to_send)
+static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
+					  u16 max_bytes_to_send)
 {
 	// Fill the FIFO, while the FIFO is not full and there are more bytes to
 	// write
+	if (max_bytes_to_send == 0)
+		return;
 	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
 					 npcm_smb_get_fifo_fullness(bus))) {
-		// write the data
-		if (bus->wr_ind < bus->wr_size) {
-			if (bus->PEC_use &&
-			    (bus->wr_ind + 1 == bus->wr_size) &&
-			    (bus->rd_size == 0 ||
-			     bus->master_or_slave == SMB_SLAVE)) {
-				// Master send PEC in write protocol, Slave send
-				// PEC in read protocol.
-				npcm_smb_write_PEC(bus);
-				bus->wr_ind++;
-			} else {
-				npcm_smb_wr_byte(bus,
-						 bus->wr_buf[bus->wr_ind++]);
-			}
-		} else {
-#ifdef SMB_WRAP_AROUND_BUFFER
-			// We're out of bytes. Ask the higher level for
-			// more bytes. Let it know that driver
-			// used all its' bytes
-
-			npcm_smb_clear_tx_fifo(bus);
+		if (bus->wr_ind < bus->wr_size)
+			npcm_smb_wr_byte(bus, bus->wr_buf[bus->wr_ind++]);
+		else
+			npcm_smb_wr_byte(bus, 0xFF);
+	}
+}
 
-			// Reset state for the remaining bytes transaction
-			bus->state = SMB_SLAVE_MATCH;
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus,
+					 u16 max_bytes_to_send)
+{
+	// Fill the FIFO, while the FIFO is not full and there are more bytes to
+	// write
+	npcm_smb_clear_fifo_int(bus);
+	npcm_smb_clear_tx_fifo(bus);
+	iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
 
-			// Notify upper layer of transaction completion
-			npcm_smb_callback(bus, SMB_SLAVE_XMIT_MISSING_DATA_IND,
-					  bus->wr_ind);
+	if (max_bytes_to_send == 0)
+		return;
 
-			iowrite8(NPCM_SMBST_SDAST, bus->reg + NPCM_SMBST);
-#else
-			npcm_smb_wr_byte(bus, 0xFF);
-#endif
+	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
+					 npcm_smb_get_fifo_fullness(bus))) {
+		if (bus->slv_wr_size > 0) {
+			npcm_smb_wr_byte(bus,
+					 bus->slv_wr_buf[bus->slv_wr_ind %
+					 SMBUS_FIFO_SIZE]);
+			bus->slv_wr_ind = (bus->slv_wr_ind + 1) %
+					   SMBUS_FIFO_SIZE;
+			bus->slv_wr_size--; // size indicates the # of bytes in
+					    // the SW FIFO, not HW.
+		} else {
+			break;
 		}
 	}
 }
+#endif
 
 // configure the FIFO before using it. If nread is -1 RX FIFO will not be
 // configured. same for	nwrite
 static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 {
+	u8 rxf_ctl = 0;
+
 	if (!bus->fifo_use)
 		return;
 	npcm_smb_select_bank(bus, SMB_BANK_1);
@@ -911,83 +780,576 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 
 	// configure RX FIFO
 	if (nread > 0) {
-		// clear LAST bit:
-		iowrite8(ioread8(bus->reg + NPCM_SMBRXF_CTL) &
-					(~NPCM_SMBRXF_CTL_LAST_PEC),
-					bus->reg + NPCM_SMBRXF_CTL);
-
-		if (nread > SMBUS_FIFO_SIZE)
-			iowrite8((ioread8(bus->reg + NPCM_SMBRXF_CTL) &
-				~NPCM_SMBRXF_CTL_RX_THR)
-				| FIELD_PREP(NPCM_SMBRXF_CTL_RX_THR,
-				SMBUS_FIFO_SIZE), bus->reg + NPCM_SMBRXF_CTL);
-		else
-			iowrite8((ioread8(bus->reg + NPCM_SMBRXF_CTL) &
-					  ~NPCM_SMBRXF_CTL_RX_THR) |
-					  FIELD_PREP(NPCM_SMBRXF_CTL_RX_THR,
-						     (u8)(nread)),
-				 bus->reg + NPCM_SMBRXF_CTL);
-
-		if (nread <= SMBUS_FIFO_SIZE && !bus->read_block_use)
-			iowrite8(ioread8(bus->reg + NPCM_SMBRXF_CTL) |
-				 NPCM_SMBRXF_CTL_LAST_PEC,
-				 bus->reg + NPCM_SMBRXF_CTL);
+		rxf_ctl = min_t(u16, (u16)nread, (u16)SMBUS_FIFO_SIZE);
+
+		// set LAST bit. if LAST is set enxt FIFO packet is nacked
+		// regular read of less then buffer size:
+		if (nread <= SMBUS_FIFO_SIZE)
+			rxf_ctl |= NPCM_SMBRXF_CTL_LAST_PEC;
+		// if we are about to read the first byte in blk rd mode,
+		// don't NACK it. BTW, if slave return zero size HW can't NACK
+		// it immidiattly, it will read extra byte and then NACK.
+		if (bus->rd_ind == 0 && bus->read_block_use) {
+			// set fifo to read one byte, no last:
+			rxf_ctl = 1;
+		}
+
+		// set fifo size:
+		iowrite8(rxf_ctl, bus->reg + NPCM_SMBRXF_CTL);
 	}
 
 	// configure TX FIFO
 	if (nwrite > 0) {
 		if (nwrite > SMBUS_FIFO_SIZE)
 			// data to send is more then FIFO size.
-			// Configure the FIFO int to be mid of FIFO.
-			iowrite8(NPCM_SMBTXF_CTL_THR_TXIE |
-				(SMBUS_FIFO_SIZE / 2),
-				bus->reg + NPCM_SMBTXF_CTL);
-		else if (nwrite > (SMBUS_FIFO_SIZE / 2) &&
-			 bus->wr_ind != 0)
-			// wr_ind != 0 means that this is not the first
-			// write. since int is in the mid of FIFO, only
-			// half of the fifo is empty.
-			// Continue to configure the FIFO int to be mid
-			// of FIFO.
-			iowrite8(NPCM_SMBTXF_CTL_THR_TXIE |
-				 (SMBUS_FIFO_SIZE / 2),
-				 bus->reg + NPCM_SMBTXF_CTL);
+			// Configure the FIFO int to be after of FIFO is cleared
+			iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBTXF_CTL);
 		else
-			// This is the either first write (wr_ind = 0)
-			// and data to send is less or equal to FIFO
-			// size.
-			// Or this is the last write and data to send
-			// is less or equal half FIFO size.
-			// In both cases disable the FIFO threshold int.
-			// The next int will happen after the FIFO will
-			// get empty.
-			iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
+			iowrite8(nwrite, bus->reg + NPCM_SMBTXF_CTL);
+
 		npcm_smb_clear_tx_fifo(bus);
 	}
 }
 
 static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 {
+	u8 data;
+
 	while (bytes_in_fifo--) {
-		// Keep read data
-		u8 data = ioread8(bus->reg + NPCM_SMBSDA);
+		npcm_smb_rd_byte(bus, &data);
 
-		npcm_smb_calc_PEC(bus, data);
-		if (bus->rd_ind < bus->rd_size) {
-			bus->rd_buf[bus->rd_ind++] = data;
-			if (bus->rd_ind == 1 && bus->read_block_use)
-				// First byte indicates length in block protocol
-				bus->rd_size = data;
+		if (bus->master_or_slave == SMB_MASTER) {
+			if (bus->rd_ind < bus->rd_size)
+				bus->rd_buf[bus->rd_ind++] = data;
+		} else { // SMB_SLAVE:
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+			if (bus->slave) {
+				bus->slv_rd_buf[bus->slv_rd_ind %
+						SMBUS_FIFO_SIZE] = data;
+				bus->slv_rd_ind++;
+				if (bus->slv_rd_ind == 1 && bus->read_block_use)
+					// 1st byte is length in block protocol
+					bus->slv_rd_size = data +
+							   (u8)bus->PEC_use +
+							(u8)bus->read_block_use;
+			}
+#endif
+		}
+	}
+}
+
+static int npcm_smb_master_abort(struct npcm_i2c *bus)
+{
+	int ret = 0;
+
+	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_ABORT);
+
+	// Only current master is allowed to issue Stop Condition
+	if (npcm_smb_is_master(bus)) {
+		npcm_smb_eob_int(bus, true);
+		npcm_smb_master_stop(bus);
+
+		// Clear NEGACK, STASTR and BER bits
+		iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK | NPCM_SMBST_STASTR,
+			 bus->reg + NPCM_SMBST);
+	}
+
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id);
+
+static int  npcm_smb_slave_enable_l(struct npcm_i2c *bus,
+				    enum smb_addr addr_type, u8 addr,
+				    bool enable)
+{
+	u8 slave_addr_reg = FIELD_PREP(NPCM_SMBADDR_A, addr) |
+		FIELD_PREP(NPCM_SMBADDR_SAEN, enable);
+
+	if (addr_type == SMB_GC_ADDR) {
+		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
+			~NPCM_SMBCTL1_GCMEN) |
+			FIELD_PREP(NPCM_SMBCTL1_GCMEN, enable),
+			bus->reg + NPCM_SMBCTL1);
+		return 0;
+	}
+	if (addr_type == SMB_ARP_ADDR) {
+		iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) &
+			~SMBCTL3_ARPMEN) |
+			FIELD_PREP(SMBCTL3_ARPMEN, enable),
+			bus->reg + NPCM_SMBCTL3);
+		return 0;
+	}
+	if (addr_type >= SMB_ARP_ADDR)
+		return -EFAULT;
+
+	// select bank 0 for address 3 to 10
+	if (addr_type > SMB_SLAVE_ADDR2)
+		npcm_smb_select_bank(bus, SMB_BANK_0);
+
+	// Set and enable the address
+	iowrite8(slave_addr_reg, bus->reg + NPCM_SMBADDR[(int)addr_type]);
+
+	// enable interrupt on slave match:
+	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_NMINTE) &
+		 ~NPCM_SMBCTL1_RWS_FIELDS, bus->reg + NPCM_SMBCTL1);
+
+	if (addr_type > SMB_SLAVE_ADDR2)
+		npcm_smb_select_bank(bus, SMB_BANK_1);
+	return 0;
+}
+
+static u8 npcm_smb_get_slave_addr(struct npcm_i2c *bus,
+				  enum smb_addr addr_type)
+{
+	u8 slave_add;
+
+	// select bank 0 for address 3 to 10
+	if (addr_type > SMB_SLAVE_ADDR2)
+		npcm_smb_select_bank(bus, SMB_BANK_0);
+
+	slave_add = ioread8(bus->reg + NPCM_SMBADDR[(int)addr_type]);
+
+	if (addr_type > SMB_SLAVE_ADDR2)
+		npcm_smb_select_bank(bus, SMB_BANK_1);
+
+	return  slave_add;
+}
+
+static int  npcm_smb_remove_slave_addr(struct npcm_i2c *bus, u8 slave_add)
+{
+	int i;
+
+	slave_add |= 0x80; //Set the enable bit
+
+	npcm_smb_select_bank(bus, SMB_BANK_0);
+
+	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++) {
+		if (ioread8(bus->reg + NPCM_SMBADDR[i]) == slave_add)
+			iowrite8(0, bus->reg + NPCM_SMBADDR[i]);
+	}
+
+	npcm_smb_select_bank(bus, SMB_BANK_1);
+
+	return 0;
+}
+
+static int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)
+{
+	u8 value = 0;
+	int ret = bus->slv_wr_ind;
+	int i;
+
+	// fill a cyclic buffer
+	for (i = 0; i < SMBUS_FIFO_SIZE; i++) {
+		if (bus->slv_wr_size >= SMBUS_FIFO_SIZE)
+			break;
+		i2c_slave_event(bus->slave, I2C_SLAVE_READ_REQUESTED, &value);
+		bus->slv_wr_buf[(bus->slv_wr_ind + bus->slv_wr_size) %
+				 SMBUS_FIFO_SIZE] = value;
+		bus->slv_wr_size++;
+		i2c_slave_event(bus->slave, I2C_SLAVE_READ_PROCESSED, &value);
+	}
+	return SMBUS_FIFO_SIZE - ret;
+}
+
+static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
+{
+	int i;
+
+	for (i = 0; i < bus->slv_rd_ind; i++)
+		i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED,
+				&bus->slv_rd_buf[i]);
+
+	// once we send bytes up, need to reset the counter of the wr buf
+	// got data from master (new offset in device), ignore wr fifo:
+	if (bus->slv_rd_ind) {
+		bus->slv_wr_size = 0;
+		bus->slv_wr_ind = 0;
+	}
+
+	bus->slv_rd_ind = 0;
+	bus->slv_rd_size = bus->adap.quirks->max_read_len;
+
+	npcm_smb_clear_fifo_int(bus);
+	npcm_smb_clear_rx_fifo(bus);
+}
+
+static bool npcm_smb_slave_receive(struct npcm_i2c *bus, u16 nread,
+				   u8 *read_data)
+{
+	bus->state = SMB_OPER_STARTED;
+	bus->operation	 = SMB_READ_OPER;
+	bus->slv_rd_size = nread;
+	bus->slv_rd_ind	= 0;
+
+	iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
+	iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBRXF_CTL);
+
+	npcm_smb_clear_tx_fifo(bus);
+	npcm_smb_clear_rx_fifo(bus);
+
+	return true;
+}
+
+static bool npcm_smb_slave_xmit(struct npcm_i2c *bus, u16 nwrite,
+				u8 *write_data)
+{
+	if (nwrite == 0)
+		return false;
+
+	bus->state = SMB_OPER_STARTED;
+	bus->operation = SMB_WRITE_OPER;
+
+	// get the next buffer
+	npcm_i2c_slave_get_wr_buf(bus);
+
+	if (nwrite > 0)
+		npcm_smb_write_to_fifo_slave(bus, nwrite);
+
+	return true;
+}
+
+// currently slave IF only supports single byte operations.
+// in order to utilyze the npcm HW FIFO, the driver will ask for 16 bytes
+// at a time, pack them in buffer, and then transmit them all together
+// to the FIFO and onward to the bus.
+// NACK on read will be once reached to bus->adap->quirks->max_read_len.
+// sending a NACK wherever the backend requests for it is not supported.
+// the next two functions allow reading to local buffer before writing it all
+// to the HW FIFO.
+// ret val: number of bytes read form the IF:
+
+static int npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)
+{
+	int left_in_fifo = FIELD_GET(NPCM_SMBTXF_STS_TX_BYTES,
+			ioread8(bus->reg + NPCM_SMBTXF_STS));
+
+	if (left_in_fifo >= SMBUS_FIFO_SIZE)
+		return left_in_fifo;
+
+	if (bus->slv_wr_size >= SMBUS_FIFO_SIZE)
+		return left_in_fifo; // fifo already full
+
+	// update the wr fifo ind, back to the untransmitted bytes:
+	bus->slv_wr_ind = bus->slv_wr_ind - left_in_fifo;
+	bus->slv_wr_size = bus->slv_wr_size + left_in_fifo;
+
+	if (bus->slv_wr_ind < 0)
+		bus->slv_wr_ind += SMBUS_FIFO_SIZE;
+
+	return left_in_fifo;
+}
+
+static void npcm_i2c_slave_rd_wr(struct npcm_i2c *bus)
+{
+	if (FIELD_GET(NPCM_SMBST_XMIT, ioread8(bus->reg + NPCM_SMBST))) {
+		// Slave got an address match with direction bit 1 so
+		// it should transmit data
+		// Write till the master will NACK
+		bus->operation = SMB_WRITE_OPER;
+		npcm_smb_slave_xmit(bus,
+				    bus->adap.quirks->max_write_len,
+				    bus->slv_wr_buf);
+	} else {
+		// Slave got an address match with direction bit 0
+		// so it should receive data.
+		// this module does not support saying no to bytes.
+		// it will always ACK.
+		bus->operation = SMB_READ_OPER;
+		npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+		bus->stop_ind = SMB_SLAVE_RCV_IND;
+		npcm_i2c_slave_send_rd_buf(bus);
+		npcm_smb_slave_receive(bus,
+				       bus->adap.quirks->max_read_len,
+				       bus->slv_rd_buf);
+	}
+}
+
+static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
+{
+	irqreturn_t ret = IRQ_NONE;
+	u8 smbst = ioread8(bus->reg + NPCM_SMBST);
+	// Slave: A NACK has occurred
+	if (FIELD_GET(NPCM_SMBST_NEGACK, smbst)) {
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
+		bus->stop_ind = SMB_NACK_IND;
+		npcm_i2c_slave_wr_buf_sync(bus);
+		if (bus->fifo_use)
+			// clear the FIFO
+			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
+				 bus->reg + NPCM_SMBFIF_CTS);
+
+		// In slave write, NACK is OK, otherwise it is a problem
+		bus->stop_ind = SMB_NO_STATUS_IND;
+		bus->operation = SMB_NO_OPER;
+		bus->own_slave_addr = 0xFF;
+
+		// Slave has to wait for SMB_STOP to decide this is the end
+		// of the transaction.
+		// Therefore transaction is not yet considered as done
+		iowrite8(NPCM_SMBST_NEGACK, bus->reg + NPCM_SMBST);
+
+		ret = IRQ_HANDLED;
+	}
+
+	// Slave mode: a Bus Error (BER) has been identified
+	if (FIELD_GET(NPCM_SMBST_BER, smbst)) {
+		// Check whether bus arbitration or Start or Stop during data
+		// xfer bus arbitration problem should not result in recovery
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER_SLV);
+		bus->stop_ind = SMB_BUS_ERR_IND;
+
+		// wait for bus busy before clear fifo
+		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO, bus->reg + NPCM_SMBFIF_CTS);
+
+		bus->state = SMB_IDLE;
+
+		// in BER case we might get 2 interrupts: one for slave one for
+		// master ( for a channel which is master\slave switching)
+		if (completion_done(&bus->cmd_complete) == false) {
+			bus->cmd_err = -EIO;
+			complete(&bus->cmd_complete);
 		}
+		bus->own_slave_addr = 0xFF;
+		iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
+		ret =  IRQ_HANDLED;
 	}
+
+	// A Slave Stop Condition has been identified
+	if (FIELD_GET(NPCM_SMBST_SLVSTP, smbst)) {
+		int bytes_in_fifo = npcm_smb_get_fifo_fullness(bus);
+
+		bus->stop_ind = SMB_SLAVE_DONE_IND;
+
+		if (bus->operation == SMB_READ_OPER) {
+			npcm_smb_read_from_fifo(bus, bytes_in_fifo);
+
+			// Slave done transmitting or receiving
+			// if the buffer is empty nothing will be sent
+		}
+
+		// Slave done transmitting or receiving
+		// if the buffer is empty nothing will be sent
+		npcm_i2c_slave_send_rd_buf(bus);
+
+		bus->stop_ind = SMB_NO_STATUS_IND;
+
+		// Note, just because we got here, it doesn't mean we through
+		// away the wr buffer.
+		// we keep it until the next received offset.
+		bus->operation = SMB_NO_OPER;
+		bus->int_cnt = 0;
+		bus->event_log_prev = bus->event_log;
+		bus->event_log = 0;
+		bus->own_slave_addr = 0xFF;
+
+		i2c_slave_event(bus->slave, I2C_SLAVE_STOP, 0);
+
+		iowrite8(NPCM_SMBST_SLVSTP, bus->reg + NPCM_SMBST);
+
+		if (bus->fifo_use) {
+			npcm_smb_clear_fifo_int(bus);
+			npcm_smb_clear_rx_fifo(bus);
+			npcm_smb_clear_tx_fifo(bus);
+
+			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
+				 bus->reg + NPCM_SMBFIF_CTS);
+		}
+
+		bus->state = SMB_IDLE;
+		ret =  IRQ_HANDLED;
+	}
+
+	// restart condition occurred and Rx-FIFO was not empty
+	if (bus->fifo_use && FIELD_GET(NPCM_SMBFIF_CTS_SLVRSTR,
+				       ioread8(bus->reg + NPCM_SMBFIF_CTS))) {
+		bus->stop_ind = SMB_SLAVE_RESTART_IND;
+
+		bus->master_or_slave = SMB_SLAVE;
+
+		if (bus->operation == SMB_READ_OPER)
+			npcm_smb_read_from_fifo(bus,
+						npcm_smb_get_fifo_fullness(bus)
+						);
+
+		bus->operation = SMB_WRITE_OPER;
+
+		iowrite8(0, bus->reg + NPCM_SMBRXF_CTL);
+
+		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO | NPCM_SMBFIF_CTS_SLVRSTR |
+			 NPCM_SMBFIF_CTS_RXF_TXE, bus->reg + NPCM_SMBFIF_CTS);
+
+		npcm_i2c_slave_rd_wr(bus);
+
+		ret =  IRQ_HANDLED;
+	}
+
+	// A Slave Address Match has been identified
+	if (FIELD_GET(NPCM_SMBST_NMATCH, smbst)) {
+		u8 info = 0;
+
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NMATCH_SLV);
+		// Address match automatically implies slave mode
+		bus->master_or_slave = SMB_SLAVE;
+
+		npcm_smb_clear_fifo_int(bus);
+		npcm_smb_clear_rx_fifo(bus);
+		npcm_smb_clear_tx_fifo(bus);
+		iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
+		iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBRXF_CTL);
+
+		if (FIELD_GET(NPCM_SMBST_XMIT, smbst)) {
+			bus->operation = SMB_WRITE_OPER;
+		} else {
+			i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_REQUESTED,
+					&info);
+			bus->operation = SMB_READ_OPER;
+		}
+
+		if (bus->own_slave_addr == 0xFF) { // unknown address
+			// Check which type of address match
+			if (FIELD_GET(NPCM_SMBCST_MATCH,
+				      ioread8(bus->reg + NPCM_SMBCST))) {
+				u16 addr;
+				enum smb_addr eaddr;
+
+				addr = ((ioread8(bus->reg + NPCM_SMBCST3) &
+					 0x7) << 7) |
+					(ioread8(bus->reg + NPCM_SMBCST2) &
+					 0x7F);
+
+				info = ffs(addr);
+				eaddr = (enum smb_addr)info;
+
+				addr = FIELD_GET(NPCM_SMBADDR_A,
+						 npcm_smb_get_slave_addr(bus,
+									 eaddr)
+						);
+				bus->own_slave_addr = addr;
+
+				if (bus->PEC_mask & BIT(info))
+					bus->PEC_use = true;
+				else
+					bus->PEC_use = false;
+			} else {
+				if (FIELD_GET(NPCM_SMBCST_GCMATCH,
+					      ioread8(bus->reg + NPCM_SMBCST)))
+					bus->own_slave_addr = 0;
+				if (FIELD_GET(NPCM_SMBCST_ARPMATCH,
+					      ioread8(bus->reg + NPCM_SMBCST)))
+					bus->own_slave_addr = 0x61;
+			}
+		} else {
+			//  Slave match can happen in two options:
+			//  1. Start, SA, read	(slave read without further ado)
+			//  2. Start, SA, read, data, restart, SA, read,  ...
+			//     (slave read in fragmented mode)
+			//  3. Start, SA, write, data, restart, SA, read, ..
+			//     (regular write-read mode)
+			if ((bus->state == SMB_OPER_STARTED &&
+			     bus->operation == SMB_READ_OPER &&
+			     bus->stop_ind == SMB_SLAVE_XMIT_IND) ||
+			     bus->stop_ind == SMB_SLAVE_RCV_IND) {
+				// slave transmit after slave receive w/o Slave
+				// Stop implies repeated start
+				bus->stop_ind = SMB_SLAVE_RESTART_IND;
+			}
+		}
+
+		if (FIELD_GET(NPCM_SMBST_XMIT, smbst))
+			bus->stop_ind = SMB_SLAVE_XMIT_IND;
+		else
+			bus->stop_ind = SMB_SLAVE_RCV_IND;
+
+		bus->state = SMB_SLAVE_MATCH;
+
+		npcm_i2c_slave_rd_wr(bus);
+
+		iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
+		ret =  IRQ_HANDLED;
+	}
+
+	// Slave SDA status is set - transmit or receive, slave
+	if (FIELD_GET(NPCM_SMBST_SDAST, smbst) ||
+	    (bus->fifo_use   &&
+	    (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
+		npcm_i2c_slave_rd_wr(bus);
+
+		iowrite8(NPCM_SMBST_SDAST, bus->reg + NPCM_SMBST);
+
+		ret =  IRQ_HANDLED;
+	} //SDAST
+
+	return ret;
+}
+
+static int  npcm_i2c_reg_slave(struct i2c_client *client)
+{
+	unsigned long lock_flags;
+	struct npcm_i2c *bus = i2c_get_adapdata(client->adapter);
+
+	bus->slave = client;
+
+	if (!bus->slave)
+		return -EINVAL;
+
+	if (client->flags & I2C_CLIENT_TEN)
+		return -EAFNOSUPPORT;
+
+	spin_lock_irqsave(&bus->lock, lock_flags);
+
+	npcm_smb_init_params(bus);
+	bus->slv_rd_size = 0;
+	bus->slv_wr_size = 0;
+	bus->slv_rd_ind = 0;
+	bus->slv_wr_ind = 0;
+	if (client->flags & I2C_CLIENT_PEC)
+		bus->PEC_use = true;
+
+	dev_info(bus->dev, "I2C%d register slave SA=0x%x, PEC=%d\n", bus->num,
+		 client->addr, bus->PEC_use);
+
+	npcm_smb_slave_enable_l(bus, SMB_SLAVE_ADDR1, client->addr, true);
+
+	npcm_smb_clear_fifo_int(bus);
+	npcm_smb_clear_rx_fifo(bus);
+	npcm_smb_clear_tx_fifo(bus);
+
+	spin_unlock_irqrestore(&bus->lock, lock_flags);
+
+	return 0;
+}
+
+static int  npcm_i2c_unreg_slave(struct i2c_client *client)
+{
+	struct npcm_i2c *bus = client->adapter->algo_data;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&bus->lock, lock_flags);
+	if (!bus->slave) {
+		spin_unlock_irqrestore(&bus->lock, lock_flags);
+		return -EINVAL;
+	}
+
+	npcm_smb_remove_slave_addr(bus, client->addr);
+
+	bus->slave = NULL;
+	spin_unlock_irqrestore(&bus->lock, lock_flags);
+
+	return 0;
 }
+#endif // CONFIG_I2C_SLAVE
 
 static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 {
-	u16 rcount;
-	u8 fifo_bytes;
+	int rcount;
+	int fifo_bytes;
 	enum smb_state_ind ind = SMB_MASTER_DONE_IND;
 
+	fifo_bytes = npcm_smb_get_fifo_fullness(bus);
+
 	rcount = bus->rd_size - bus->rd_ind;
 
 	// In order not to change the RX_TRH during transaction (we found that
@@ -997,22 +1359,20 @@ static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 	// and in the next int we read rest of the data.
 	if (rcount < (2 * SMBUS_FIFO_SIZE) && rcount > SMBUS_FIFO_SIZE)
 		fifo_bytes = (u8)(rcount - SMBUS_FIFO_SIZE);
-	else
-		fifo_bytes = npcm_smb_get_fifo_fullness(bus);
 
-	if (rcount - fifo_bytes == 0) {
-		// last byte is about to be read - end of transaction.
+	if ((rcount - fifo_bytes) <= 0) {
+		// last bytes are about to be read - end of transaction.
 		// Stop should be set before reading last byte.
-		npcm_smb_eob_int(bus, true);
-		npcm_smb_master_stop(bus);
-		npcm_smb_read_from_fifo(bus, fifo_bytes);
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ4);
 
-		if (npcm_smb_get_PEC(bus) != 0)
-			ind = SMB_MASTER_PEC_ERR_IND;
 		bus->state = SMB_STOP_PENDING;
 		bus->stop_ind = ind;
 
+		npcm_smb_eob_int(bus, true);
+		npcm_smb_master_stop(bus);
+		npcm_smb_read_from_fifo(bus, fifo_bytes);
 	} else {
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ3);
 		npcm_smb_read_from_fifo(bus, fifo_bytes);
 		rcount = bus->rd_size - bus->rd_ind;
 		npcm_smb_set_fifo(bus, rcount, -1);
@@ -1025,219 +1385,150 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_WRITE);
 	if (bus->fifo_use)
-		npcm_smb_clear_tx_fifo(bus);
+		npcm_smb_clear_tx_fifo(bus); // clear the TX fifo status bit
 
 	// Master write operation - last byte handling
 	if (bus->wr_ind == bus->wr_size) {
 		if (bus->fifo_use && npcm_smb_get_fifo_fullness(bus) > 0)
-	// No more bytes to send (to add to the FIFO), however the FIFO is not
-	// empty yet. It is still in the middle of tx. Currently there's nothing
-	// to do except for waiting to the end of the tx.
-	// We will get an int when the FIFO will get empty.
+			// No more bytes to send (to add to the FIFO),
+			// however the FIFO is not empty yet. It is
+			// still in the middle of tx. Currently there's nothing
+			// to do except for waiting to the end of the tx.
+			// We will get an int when the FIFO will get empty.
 			return;
 
 		if (bus->rd_size == 0) {
 			// all bytes have been written, in a pure wr operation
 			npcm_smb_eob_int(bus, true);
 
-			// Issue a STOP condition on the bus
+			bus->state = SMB_STOP_PENDING;
+			bus->stop_ind = SMB_MASTER_DONE_IND;
+
 			npcm_smb_master_stop(bus);
 			// Clear SDA Status bit (by writing dummy byte)
 			npcm_smb_wr_byte(bus, 0xFF);
 
-			bus->state = SMB_STOP_PENDING;
-			bus->stop_ind = SMB_MASTER_DONE_IND;
 		} else {
 			// last write-byte written on previous int - need to
 			// restart & send slave address
-			if (bus->PEC_use && !bus->read_block_use &&
-			    !npcm_smb_is_quick(bus))
-			    // PEC is used but the protocol is not block read
-			    // then we add extra bytes for PEC support
-				bus->rd_size += 1;
-
-			if (bus->fifo_use) {
-				if (bus->rd_size == 1 || bus->read_block_use) {
-					// SMBus Block read transaction.
-					iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
-					iowrite8(1, bus->reg + NPCM_SMBRXF_CTL);
-				}
-			}
-
 			npcm_smb_set_fifo(bus, bus->rd_size, -1);
 
-			// Generate (Repeated) Start upon next write to SDA
+			// Generate repeated start upon next write to SDA
 			npcm_smb_master_start(bus);
 
 			if (bus->rd_size == 1)
-
-	// Receiving one byte only - stall after successful completion of send
-	// address byte. If we NACK here, and slave doesn't ACK the address, we
-	// might unintentionally NACK the next multi-byte read
-
+				// Receiving one byte only - stall after
+				// successful completion of send
+				// address byte. If we NACK here,
+				// and slave doesn't ACK the address, we
+				// might unintentionally NACK the next
+				// multi-byte read
 				npcm_smb_stall_after_start(bus, true);
 
-			// send the slave address in read direction
-			npcm_smb_wr_byte(bus, bus->dest_addr | 0x1);
-
 			// Next int will occur on read
 			bus->operation = SMB_READ_OPER;
+
+			// send the slave address in read direction
+			npcm_smb_wr_byte(bus, bus->dest_addr | 0x1);
 		}
 	} else {
-		if (bus->PEC_use && !npcm_smb_is_quick(bus))
-			// extra bytes for PEC support
-			bus->wr_size += 1;
-
 		// write next byte not last byte and not slave address
 		if (!bus->fifo_use || bus->wr_size == 1) {
-			if (bus->PEC_use && bus->rd_size == 0 &&
-			    (bus->wr_ind + 1 == bus->wr_size)) {
-				// Master write protocol to send PEC byte.
-				npcm_smb_write_PEC(bus);
-				bus->wr_ind++;
-			} else {
-				npcm_smb_wr_byte(bus,
-						 bus->wr_buf[bus->wr_ind++]);
-			}
-		} else { // FIFO is used
+			npcm_smb_wr_byte(bus, bus->wr_buf[bus->wr_ind++]);
+		} else {
 			wcount = bus->wr_size - bus->wr_ind;
 			npcm_smb_set_fifo(bus, -1, wcount);
-			npcm_smb_write_to_fifo(bus, wcount);
+			npcm_smb_write_to_fifo_master(bus, wcount);
 		}
 	}
 }
 
 static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 {
-	u16 block_zero_bytes;
-	u32 fifo_bytes;
+	u16 block_extra_bytes_size;
+	u8 data;
 
 	// Master read operation (pure read or following a write operation).
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ);
 
-	// Initialize number of bytes to include only the first byte (presents
-	// a case where number of bytes to read is zero); add PEC if applicable
-	block_zero_bytes = 1;
-	if (bus->PEC_use)
-		block_zero_bytes++;
-
-	fifo_bytes = FIELD_GET(NPCM_SMBRXF_CTL_RX_THR,
-			       ioread8(bus->reg + NPCM_SMBRXF_CTL));
+	// added bytes to the packet:
+	block_extra_bytes_size = (u8)bus->read_block_use + (u8)bus->PEC_use;
 
 	// Perform master read, distinguishing between last byte and the rest of
 	// the bytes. The last byte should be read when the clock is stopped
-	if ((bus->rd_ind < (bus->rd_size - 1)) ||  bus->fifo_use) {
-		u8 data;
-
-		// byte to be read is not the last one
-		// Check if byte-before-last is about to be read
-		if ((bus->rd_ind == (bus->rd_size - 2)) &&
-		    !bus->fifo_use){
-			// Set nack before reading byte-before-last, so that
-			// nack will be generated after receive of last byte
-			npcm_smb_nack(bus);
-
-			if (!FIELD_GET(NPCM_SMBST_SDAST,
-				       ioread8(bus->reg + NPCM_SMBST))) {
-				// No data available - reset state for new xfer
-				bus->state = SMB_IDLE;
-
-				// Notify upper layer of rx completion
-				npcm_smb_callback(bus, SMB_NO_DATA_IND,
-						  bus->rd_ind);
-			}
-		} else if (bus->rd_ind == 0) { //first byte handling:
-			// in block protocol first byte is the size
-			if (bus->read_block_use) {
-				npcm_smb_rd_byte(bus, &data);
-
-				// First byte indicates length in block protocol
-				bus->rd_buf[bus->rd_ind++] = data;
-				bus->rd_size = data + 1;
-
-				if (bus->PEC_use) {
-					bus->rd_size += 1;
-					data += 1;
-				}
-
-				if (bus->fifo_use) {
-					iowrite8(NPCM_SMBFIF_CTS_RXF_TXE |
-						 ioread8(bus->reg +
-							 NPCM_SMBFIF_CTS),
-						 bus->reg + NPCM_SMBFIF_CTS);
-
-					// first byte in block protocol
-					// is zero -> not supported. read at
-					// least one byte
-					if (data == 0)
-						data = 1;
-				}
-				npcm_smb_set_fifo(bus, bus->rd_size, -1);
-			} else {
-				if (!bus->fifo_use) {
-					npcm_smb_rd_byte(bus, &data);
-					bus->rd_buf[bus->rd_ind++] = data;
-				} else {
-					npcm_smb_clear_tx_fifo(bus);
-					npcm_smb_master_fifo_read(bus);
-				}
-			}
-
-		} else {
-			if (bus->fifo_use) {
-				if (bus->rd_size == block_zero_bytes &&
-				    bus->read_block_use) {
-					npcm_smb_eob_int(bus, true);
-					npcm_smb_master_stop(bus);
-					npcm_smb_read_from_fifo(bus,
-								fifo_bytes);
-					bus->state = SMB_STOP_PENDING;
-					bus->stop_ind = SMB_BLOCK_BYTES_ERR_IND;
-
-				} else {
-					npcm_smb_master_fifo_read(bus);
-				}
-			} else {
-				npcm_smb_rd_byte(bus, &data);
-				bus->rd_buf[bus->rd_ind++] = data;
-			}
-		}
-	} else {
-		// last byte is about to be read - end of transaction.
-		// Stop should be set before reading last byte.
-		u8 data;
-		enum smb_state_ind ind = SMB_MASTER_DONE_IND;
+	if (bus->rd_ind == 0) { //first byte handling:
+		// in block protocol first byte is the size
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ1);
+		if (bus->read_block_use) {
+			// first byte in block protocol is the size:
+			npcm_smb_rd_byte(bus, &data);
 
-		npcm_smb_eob_int(bus, true);
+			// if slave returned illegal size. read up to 32 bytes.
+			if (data >= I2C_SMBUS_BLOCK_MAX)
+				data = I2C_SMBUS_BLOCK_MAX;
 
-		npcm_smb_master_stop(bus);
+			// is data is 0 -> not supported. read at least one byte
+			if (data == 0)
+				data = 1;
 
-		npcm_smb_rd_byte(bus, &data);
+			bus->rd_size = data + block_extra_bytes_size;
 
-		if (bus->rd_size == block_zero_bytes && bus->read_block_use) {
-			ind = SMB_BLOCK_BYTES_ERR_IND;
-		} else {
 			bus->rd_buf[bus->rd_ind++] = data;
-			if (npcm_smb_get_PEC(bus) != 0)
-				ind = SMB_MASTER_PEC_ERR_IND;
-		}
 
-		bus->state = SMB_STOP_PENDING;
-		bus->stop_ind = ind;
+			// clear RX FIFO interrupt status:
+			if (bus->fifo_use) {
+				iowrite8(NPCM_SMBFIF_CTS_RXF_TXE |
+					 ioread8(bus->reg + NPCM_SMBFIF_CTS),
+					 bus->reg + NPCM_SMBFIF_CTS);
+			}
+
+			npcm_smb_set_fifo(bus, (bus->rd_size - 1), -1);
+			npcm_smb_stall_after_start(bus, false);
+		} else {
+			npcm_smb_clear_tx_fifo(bus);
+			npcm_smb_master_fifo_read(bus);
+		}
+	} else {
+		if (bus->rd_size == block_extra_bytes_size &&
+		    bus->read_block_use) {
+			bus->state = SMB_STOP_PENDING;
+			bus->stop_ind = SMB_BLOCK_BYTES_ERR_IND;
+			bus->cmd_err = -EIO;
+			npcm_smb_eob_int(bus, true);
+			npcm_smb_master_stop(bus);
+			npcm_smb_read_from_fifo(bus,
+						npcm_smb_get_fifo_fullness(bus)
+						);
+		} else {
+			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ2);
+			npcm_smb_master_fifo_read(bus);
+		}
 	}
 }
 
-static void npcm_smb_int_master_handler(struct npcm_i2c *bus)
+static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 {
-	// A negative acknowledge has occurred
+	irqreturn_t ret = IRQ_NONE;
+	u8 fif_cts;
+
+	if (FIELD_GET(NPCM_SMBST_NMATCH, ioread8(bus->reg + NPCM_SMBST))) {
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NMATCH_MSTR);
+		iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
+		npcm_smb_nack(bus);
+		bus->stop_ind = SMB_BUS_ERR_IND;
+		npcm_smb_callback(bus, bus->stop_ind, npcm_smb_get_index(bus));
+
+		return IRQ_HANDLED;
+	}
+	// A NACK has occurred
 	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
 		if (bus->fifo_use) {
 			// if there are still untransmitted bytes in TX FIFO
 			// reduce them from wr_ind
-
 			if (bus->operation == SMB_WRITE_OPER)
 				bus->wr_ind -= npcm_smb_get_fifo_fullness(bus);
+
 			// clear the FIFO
 			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
@@ -1245,41 +1536,59 @@ static void npcm_smb_int_master_handler(struct npcm_i2c *bus)
 
 		// In master write operation, NACK is a problem
 		// number of bytes sent to master less than required
-		npcm_smb_master_abort(bus);
+		bus->stop_ind = SMB_NACK_IND;
+		// Only current master is allowed to issue Stop Condition
+		if (npcm_smb_is_master(bus)) {
+			// stopping in the middle, not waiting for ints anymore
+			npcm_smb_eob_int(bus,  false);
+
+			npcm_smb_master_stop(bus);
+
+			// Clear NEGACK, STASTR and BER bits
+			// In Master mode, NEGACK should be cleared only after
+			// generating STOP.
+			// In such case, the bus is released from stall only
+			// after the software clears NEGACK bit.
+			// Then a Stop condition is sent.
+			iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK |
+				 NPCM_SMBST_STASTR, bus->reg + NPCM_SMBST);
+
+			npcm_smb_wait_for_bus_free(bus, false);
+		}
 		bus->state = SMB_IDLE;
 
-		// In Master mode, NEGACK should be cleared only after
+		// In Master mode, NACK should be cleared only after
 		// generating STOP.
 		// In such case, the bus is released from stall only after the
-		// software clears NEGACK bit.
+		// software clears NACK bit.
 		// Then a Stop condition is sent.
-		iowrite8(NPCM_SMBST_NEGACK, bus->reg + NPCM_SMBST);
-		npcm_smb_callback(bus, SMB_NACK_IND, bus->wr_ind);
-		return;
+		npcm_smb_callback(bus, bus->stop_ind, bus->wr_ind);
+		return IRQ_HANDLED;
 	}
 
 	// Master mode: a Bus Error has been identified
 	if (FIELD_GET(NPCM_SMBST_BER, ioread8(bus->reg + NPCM_SMBST))) {
 		// Check whether bus arbitration or Start or Stop during data
 		// xfer bus arbitration problem should not result in recovery
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER);
+		bus->stop_ind = SMB_BUS_ERR_IND;
 		if (npcm_smb_is_master(bus)) {
-			// Only current master is allowed to issue stop
 			npcm_smb_master_abort(bus);
 		} else {
-			// Bus arbitration loss
-			if (bus->retry_count-- > 0) {
-				// Perform a retry (generate a start condition)
-				// as soon as the SMBus is free
-				iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-				npcm_smb_master_start(bus);
-				return;
-			}
+			// Clear NEGACK, STASTR and BER bits
+			iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK |
+				 NPCM_SMBST_STASTR, bus->reg + NPCM_SMBST);
+
+			// Clear BB (BUS BUSY) bit
+			iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
+
+			bus->cmd_err = -EAGAIN;
+			npcm_smb_callback(bus, bus->stop_ind,
+					  npcm_smb_get_index(bus));
 		}
-		iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
 		bus->state = SMB_IDLE;
-		npcm_smb_callback(bus, SMB_BUS_ERR_IND,
-				  npcm_smb_get_index(bus));
-		return;
+		ret =  IRQ_HANDLED;
+		return ret;
 	}
 
 	// A Master End of Busy (meaning Stop Condition happened)
@@ -1291,25 +1600,21 @@ static void npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_EOB);
 		npcm_smb_eob_int(bus, false);
 		bus->state = SMB_IDLE;
-		if (npcm_smb_is_quick(bus))
-			npcm_smb_callback(bus, bus->stop_ind, 0);
-		else
-			npcm_smb_callback(bus, bus->stop_ind, bus->rd_ind);
-		return;
+		npcm_smb_callback(bus, bus->stop_ind, bus->rd_ind);
+		return IRQ_HANDLED;
 	}
 
 	// Address sent and requested stall occurred (Master mode)
 	if (FIELD_GET(NPCM_SMBST_STASTR, ioread8(bus->reg + NPCM_SMBST))) {
-		// Check for Quick Command SMBus protocol
-		if (npcm_smb_is_quick(bus)) {
-			npcm_smb_eob_int(bus, true);
-			npcm_smb_master_stop(bus);
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STALL);
 
-			// Update status
+		if (npcm_smb_is_quick(bus)) {
 			bus->state = SMB_STOP_PENDING;
 			bus->stop_ind = SMB_MASTER_DONE_IND;
+			npcm_smb_eob_int(bus, true);
+			npcm_smb_master_stop(bus);
 
-		} else if (bus->rd_size == 1) {
+		} else if ((bus->rd_size == 1) && !bus->read_block_use) {
 			// Receiving one byte only - set NACK after ensuring
 			// slave ACKed the address byte
 			npcm_smb_nack(bus);
@@ -1321,152 +1626,264 @@ static void npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		// Clear stall only after setting STOP
 		iowrite8(NPCM_SMBST_STASTR, bus->reg + NPCM_SMBST);
 
-		return;
+		ret =  IRQ_HANDLED;
 	}
 
-	// SDA status is set - transmit or receive, master
+	// SDA status is set - TX or RX, master
 	if (FIELD_GET(NPCM_SMBST_SDAST, ioread8(bus->reg + NPCM_SMBST)) ||
 	    (bus->fifo_use &&
-	    (npcm_smb_tx_fifo_full(bus) || npcm_smb_rx_fifo_full(bus)))) {
+	    (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
 		// Status Bit is cleared by writing to or reading from SDA
 		// (depending on current direction)
-		switch (bus->state) {
-		// Handle unsuccessful bus mastership
-		case SMB_IDLE:
-			npcm_smb_master_abort(bus);
-			return;
 
-		case SMB_MASTER_START:
+		// Send address:
+		if (bus->state == SMB_IDLE) {
 			if (npcm_smb_is_master(bus)) {
-				u8 addr_byte = bus->dest_addr;
+				bus->stop_ind = SMB_WAKE_UP_IND;
 
-				bus->crc_data = 0;
-				if (npcm_smb_is_quick(bus)) {
+				// test stall on start
+				if (npcm_smb_is_quick(bus) ||
+				    bus->read_block_use)
 					// Need to stall after successful
 					// completion of sending address byte
 					npcm_smb_stall_after_start(bus, true);
-				} else if (bus->wr_size == 0) {
-					// Set direction to Read
-					addr_byte |= (u8)0x1;
-					bus->operation = SMB_READ_OPER;
-				} else {
-					bus->operation = SMB_WRITE_OPER;
-				}
-
-	// Receiving one byte only - stall after successful completion of
-	// sending address byte. If we NACK here, and slave doesn't ACK the
-	// address, we might unintentionally NACK the next multi-byte read
+				else
+					npcm_smb_stall_after_start(bus, false);
+
+				// Receiving one byte only - stall after
+				// successful completion of sending address byte
+				// If we NACK here, and slave doesn't ACK the
+				// address, we might unintentionally NACK
+				// the next multi-byte read
 				if (bus->wr_size == 0 && bus->rd_size == 1)
 					npcm_smb_stall_after_start(bus, true);
 
-				// Write the address to the bus
+				// Initiate SMBus master transaction
+				// Generate a Start condition on the SMBus
+
+				// select bank 1 for FIFO regs
+				npcm_smb_select_bank(bus, SMB_BANK_1);
+
+				fif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
+
+				// clear FIFO and relevant status bits.
+				iowrite8((fif_cts & ~NPCM_SMBFIF_CTS_SLVRSTR)
+					| NPCM_SMBFIF_CTS_CLR_FIFO,
+					 bus->reg + NPCM_SMBFIF_CTS);
+
+				// and enable it
+				iowrite8((fif_cts & ~NPCM_SMBFIF_CTS_SLVRSTR)
+					| NPCM_SMBFIF_CTS_RXF_TXE,
+					 bus->reg + NPCM_SMBFIF_CTS);
+
+				// Configure the FIFO threshold
+				// according to the needed # of bytes to read.
+				// Note: due to HW limitation can't config the
+				// rx fifo before
+				// got and ACK on the restart. LAST bit will not
+				// be reset unless RX completed.
+				// It will stay set on the next tx.
+				if (bus->wr_size)
+					npcm_smb_set_fifo(bus, -1,
+							  bus->wr_size);
+				else
+					npcm_smb_set_fifo(bus, bus->rd_size,
+							  -1);
+
 				bus->state = SMB_OPER_STARTED;
-				npcm_smb_wr_byte(bus, addr_byte);
-			} else {
-				dev_err(bus->dev,
-					"SDA, bus%d is not master, wr %d 0x%x...\n",
-					bus->num, bus->wr_size,
-					bus->wr_buf[0]);
+
+				if (npcm_smb_is_quick(bus) || bus->wr_size)
+					npcm_smb_wr_byte(bus, bus->dest_addr);
+				else
+					npcm_smb_wr_byte(bus, bus->dest_addr |
+							      0x01);
 			}
-			break;
 
+			return IRQ_HANDLED;
 		// SDA status is set - transmit or receive: Handle master mode
-		case SMB_OPER_STARTED:
-			if (bus->operation == SMB_WRITE_OPER)
-				npcm_smb_int_master_handler_write(bus);
-			else if (bus->operation == SMB_READ_OPER)
+		} else {
+			if ((NPCM_SMBST_XMIT &
+			     ioread8(bus->reg + NPCM_SMBST)) == 0) {
+				bus->operation = SMB_READ_OPER;
 				npcm_smb_int_master_handler_read(bus);
-			else
-				pr_err("I2C%d: unknown operation\n", bus->num);
-			break;
-		default:
-			dev_err(bus->dev, "i2c%d master sda err on state machine\n",
-				bus->num);
+			} else {
+				bus->operation = SMB_WRITE_OPER;
+				npcm_smb_int_master_handler_write(bus);
+			}
 		}
+		ret =  IRQ_HANDLED;
 	}
+
+	return ret;
+}
+
+static int npcm_smb_get_SCL(struct i2c_adapter *_adap)
+{
+	unsigned int ret = 0;
+	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
+	u32 offset = 0;
+
+	offset = 0;
+	ret = FIELD_GET(SMBCTL3_SCL_LVL, ioread32(bus->reg + NPCM_SMBCTL3));
+
+	pr_debug("i2c%d get SCL 0x%08X\n", bus->num, ret);
+
+	return (ret >> (offset)) & 0x01;
+}
+
+static int npcm_smb_get_SDA(struct i2c_adapter *_adap)
+{
+	unsigned int ret = 0;
+	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
+	u32 offset = 0;
+
+	offset = 0;
+	ret = FIELD_GET(SMBCTL3_SDA_LVL, ioread32(bus->reg + NPCM_SMBCTL3));
+
+	pr_debug("i2c%d get SDA 0x%08X\n", bus->num, ret);
+
+	return (ret >> (offset)) & 0x01;
 }
 
-static int npcm_smb_recovery(struct i2c_adapter *_adap)
+// recovery using TGCLK functionality of the module
+static int npcm_smb_recovery_tgclk(struct i2c_adapter *_adap)
 {
-	u8   iter = 27;	  // Allow one byte to be sent by the Slave
-	u16  timeout;
+	int  iter = 27;	  // Allow 3 bytes to be sent by the Slave
+	int  retries = 0;
 	bool done = false;
+	int  status = -(ENOTRECOVERABLE);
+	u8   fif_cts;
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
-	dev_info(bus->dev, "recovery bus%d\n", bus->num);
+	dev_dbg(bus->dev, "TGCLK recovery bus%d\n", bus->num);
 
-	might_sleep();
+	if ((npcm_smb_get_SDA(_adap) == 1) && (npcm_smb_get_SCL(_adap) == 1)) {
+		dev_dbg(bus->dev, "TGCLK recovery bus%d: skipped bus not stuck",
+			bus->num);
+		npcm_smb_reset(bus);
+		return status;
+	}
 
 	// Disable int
 	npcm_smb_int_enable(bus, false);
 
+	npcm_smb_disable(bus);
+	npcm_smb_enable(bus);
+	iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
+	npcm_smb_clear_tx_fifo(bus);
+	npcm_smb_clear_rx_fifo(bus);
+	iowrite8(0, bus->reg + NPCM_SMBRXF_CTL);
+	iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
+	npcm_smb_stall_after_start(bus, false);
+
+	// select bank 1 for FIFO regs
+	npcm_smb_select_bank(bus, SMB_BANK_1);
+
+	fif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
+
+	// clear FIFO and relevant status bits.
+	iowrite8((fif_cts & ~NPCM_SMBFIF_CTS_SLVRSTR) |
+		  NPCM_SMBFIF_CTS_CLR_FIFO,
+		  bus->reg + NPCM_SMBFIF_CTS);
+
+	npcm_smb_set_fifo(bus, -1, 0);
+
 	// Check If the SDA line is active (low)
-	if (FIELD_GET(NPCM_SMBCST_TSDA, ioread8(bus->reg + NPCM_SMBCST)) == 0) {
+	if (npcm_smb_get_SDA(_adap) == 0) {
 		// Repeat the following sequence until SDA is released
 		do {
 			// Issue a single SCL cycle
 			iowrite8(NPCM_SMBCST_TGSCL, bus->reg + NPCM_SMBCST);
-			timeout = ABORT_TIMEOUT;
-			while (timeout != 0 &&
+			retries = 10;
+			while (retries != 0 &&
 			       FIELD_GET(NPCM_SMBCST_TGSCL,
-					 ioread8(bus->reg + NPCM_SMBCST) == 0))
-				timeout--;
+					 ioread8(bus->reg + NPCM_SMBCST))) {
+				udelay(20);
+				retries--;
+			}
 
+			// tgclk failed to toggle
+			if (retries == 0)
+				dev_dbg(bus->dev, "\t toggle timeout\n");
 			// If SDA line is inactive (high), stop
-			if (FIELD_GET(NPCM_SMBCST_TSDA,
-				      ioread8(bus->reg + NPCM_SMBCST)) == 1)
+			if (npcm_smb_get_SDA(_adap))
 				done = true;
 		} while ((!done) && (--iter != 0));
 
-		// If SDA line is released (high)
+		// If SDA line is released: send start-addr-stop, to re-sync.
 		if (done) {
-			// Clear BB (BUS BUSY) bit
-			iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
-
-			// Generate a START, to synchronize Master and Slave
 			npcm_smb_master_start(bus);
 
-			// Wait until START condition is sent, or timeout
-			timeout = ABORT_TIMEOUT;
-			while (timeout != 0 && !npcm_smb_is_master(bus))
-				timeout--;
+			// Wait until START condition is sent, or RETRIES_NUM
+			retries = RETRIES_NUM;
+			while (retries && !npcm_smb_is_master(bus)) {
+				udelay(20);
+				retries--;
+			}
 
 			// If START condition was sent
-			if (timeout > 0) {
-				// Send an address byte
+			if (retries > 0) {
+				// Send an address byte in write direction:
 				npcm_smb_wr_byte(bus, bus->dest_addr);
-
-				// Generate a STOP condition
+				udelay(200);
 				npcm_smb_master_stop(bus);
+				udelay(200);
+				status = 0;
 			}
-			return 0;
 		}
 	}
 
-	// check if success:
-	if (npcm_smb_get_SCL(_adap) == 1 && npcm_smb_get_SDA(_adap) == 1)
-		goto npcm_smb_recovery_done;
+	// if bus is still stuck: total reset: set SCL low for 35ms:
+	if (unlikely(npcm_smb_get_SDA(_adap) == 0)) {
+		// Generate a START, to synchronize Master and Slave
+		npcm_smb_master_start(bus);
 
-	// hold clock low for 35ms: 25 and some spair:
-	npcm_smb_set_SCL(_adap, 0);
-	usleep_range(35000, 40000);
-	npcm_smb_set_SCL(_adap, 1);
-	usleep_range(1000, 2000);
+		// Wait until START condition is sent, or RETRIES_NUM
+		retries = RETRIES_NUM;
+		while (retries && !npcm_smb_is_master(bus))
+			retries--;
 
-	// check if success:
-	if (npcm_smb_get_SCL(_adap) == 1 && npcm_smb_get_SDA(_adap) == 1)
-		goto npcm_smb_recovery_done;
+		// set SCL low for a long time (note: this is unlikely)
+		usleep_range(25000, 35000);
+		npcm_smb_master_stop(bus);
+		udelay(200);
+		status = 0;
+	}
 
-	return 0;
+	dev_dbg(bus->dev, "TGCLK done, iter = %d, done = %d, retries = %d\n",
+		27 - iter, done, retries);
+	// Enable SMB int and New Address Match int source
+	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_NMINTE) &
+		 ~NPCM_SMBCTL1_RWS_FIELDS,
+		 bus->reg + NPCM_SMBCTL1);
+	npcm_smb_reset(bus);
+	npcm_smb_int_enable(bus, true);
+	return status;
+}
+
+// recovery using bit banging functionality of the module
+static int npcm_smb_recovery_init(struct i2c_adapter *_adap)
+{
+	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
+	struct i2c_bus_recovery_info *rinfo = &bus->rinfo;
 
-npcm_smb_recovery_done:
+	rinfo->recover_bus = npcm_smb_recovery_tgclk;
+	rinfo->prepare_recovery = NULL;
+	rinfo->unprepare_recovery = NULL;
+	rinfo->set_scl = NULL;
+	rinfo->set_sda = NULL;
 
-	npcm_smb_int_enable(bus, true);
-	return -(ENOTRECOVERABLE);
+	dev_dbg(bus->dev, "i2c gpio recovery using TGCLK\n");
+
+	rinfo->get_scl = npcm_smb_get_SCL;
+	rinfo->get_sda = npcm_smb_get_SDA;
+
+	_adap->bus_recovery_info = rinfo;
+
+	return 0;
 }
 
-static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
-			      u32 bus_freq)
+static bool npcm_smb_init_clk(struct npcm_i2c *bus, u32 bus_freq)
 {
 	u32  k1 = 0;
 	u32  k2 = 0;
@@ -1477,6 +1894,7 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 	u32  src_clk_freq; // in KHz
 
 	src_clk_freq = bus->apb_clk / 1000;
+	bus->bus_freq = bus_freq;
 
 	if (bus_freq <= SMBUS_FREQ_100KHZ) {
 		sclfrq = src_clk_freq / (bus_freq * 4);
@@ -1496,30 +1914,31 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 		sclfrq = 0;
 		fast_mode = true;
 
-		if ((mode == SMB_MASTER && src_clk_freq < 7500) ||
-		    (mode == SMB_SLAVE && src_clk_freq < 10000))
-		  // 400KHZ cannot be supported for master core clock < 7.5 MHZ
-		  // or slave core clock < 10 MHZ
+		if (src_clk_freq < 7500)
+			// 400KHZ cannot be supported for core clock < 7.5 MHZ
 			return false;
 
+		else if (src_clk_freq >= 50000) {
+			k1 = 80;
+			k2 = 48;
+			hldt = 12;
+			dbnct = 7;
+		}
+
 		// Master or Slave with frequency > 25 MHZ
-		if (mode == SMB_MASTER || src_clk_freq > 25000) {
+		else if (src_clk_freq > 25000) {
 			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 300,
 							 1000000) + 7;
-			if (mode == SMB_MASTER) {
-				k1 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 1600,
-							   1000000);
-				k2 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 900,
-							   1000000);
-				k1 = round_up(k1, 2);
-				k2 = round_up(k2 + 1, 2);
-				if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
-				    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)
-					return false;
-			}
-		} else { // Slave with frequency 10-25 MHZ
-			hldt = 7;
-			dbnct = 2;
+
+			k1 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 1600,
+						   1000000);
+			k2 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 900,
+						   1000000);
+			k1 = round_up(k1, 2);
+			k2 = round_up(k2 + 1, 2);
+			if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
+			    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)
+				return false;
 		}
 	}
 
@@ -1527,32 +1946,26 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 		sclfrq = 0;
 		fast_mode = true;
 
-		if ((mode == SMB_MASTER && src_clk_freq < 15000) ||
-		    (mode == SMB_SLAVE	&& src_clk_freq < 24000))
+		if (src_clk_freq < 24000)
 		// 1MHZ cannot be supported for master core clock < 15 MHZ
 		// or slave core clock < 24 MHZ
 			return false;
 
-		if (mode == SMB_MASTER) {
-			k1 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 620,
-							     1000000)), 2);
-			k2 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 380,
-							     1000000) + 1), 2);
-			if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
-			    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX) {
-				return false;
-			}
-		}
+		k1 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 620,
+						     1000000)), 2);
+		k2 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 380,
+						     1000000) + 1), 2);
+		if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
+		    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)
+			return false;
 
 		// Master or Slave with frequency > 40 MHZ
-		if (mode == SMB_MASTER || src_clk_freq > 40000) {
+		if (src_clk_freq > 40000) {
 			// Set HLDT:
 			// SDA hold time:  (HLDT-7) * T(CLK) >= 120
 			// HLDT = 120/T(CLK) + 7 = 120 * FREQ(CLK) + 7
 			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 120,
 							 1000000) + 7;
-
-		// Slave with frequency 24-40 MHZ
 		} else {
 			hldt = 7;
 			dbnct = 2;
@@ -1563,47 +1976,33 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 	else
 		return false;
 
-	// After clock parameters calculation update the reg
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2)
-		& ~SMBCTL2_SCLFRQ6_0) | FIELD_PREP(SMBCTL2_SCLFRQ6_0,
-		sclfrq & 0x7F), bus->reg + NPCM_SMBCTL2);
+	// After clock parameters calculation update reg (ENABLE should be 0):
+	iowrite8(FIELD_PREP(SMBCTL2_SCLFRQ6_0, sclfrq & 0x7F),
+		 bus->reg + NPCM_SMBCTL2);
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_SCLFRQ8_7) |
+	// force to bank 0, set SCL and fast mode
+	iowrite8(FIELD_PREP(SMBCTL3_400K_MODE, fast_mode) |
 		 FIELD_PREP(SMBCTL3_SCLFRQ8_7, (sclfrq >> 7) & 0x3),
 		 bus->reg + NPCM_SMBCTL3);
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_400K_MODE) |
-		 FIELD_PREP(SMBCTL3_400K_MODE, fast_mode),
-		 bus->reg + NPCM_SMBCTL3);
-
 	// Select Bank 0 to access NPCM_SMBCTL4/NPCM_SMBCTL5
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
 	if (bus_freq >= SMBUS_FREQ_400KHZ) {
-		// k1 and k2 are relevant for master mode only
-		if (mode == SMB_MASTER) {
-			// Set SCL Low/High Time:
-			// k1 = 2 * SCLLT7-0 -> Low Time  = k1 / 2
-			// k2 = 2 * SCLLT7-0 -> High Time = k2 / 2
-			iowrite8((u8)k1 / 2, bus->reg + NPCM_SMBSCLLT);
-			iowrite8((u8)k2 / 2, bus->reg + NPCM_SMBSCLHT);
-		} else { // DBNCT is relevant for slave mode only
-			iowrite8((ioread8(bus->reg + NPCM_SMBCTL5) &
-				 ~SMBCTL5_DBNCT) |
-				 FIELD_PREP(SMBCTL5_DBNCT, dbnct),
-				 bus->reg + NPCM_SMBCTL5);
-		}
+		// Set SCL Low/High Time:
+		// k1 = 2 * SCLLT7-0 -> Low Time  = k1 / 2
+		// k2 = 2 * SCLLT7-0 -> High Time = k2 / 2
+		iowrite8((u8)k1 / 2, bus->reg + NPCM_SMBSCLLT);
+		iowrite8((u8)k2 / 2, bus->reg + NPCM_SMBSCLHT);
+
+		iowrite8(dbnct, bus->reg + NPCM_SMBCTL5);
 	}
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL4) & ~SMBCTL4_HLDT)
-		 | FIELD_PREP(SMBCTL4_HLDT, hldt), bus->reg + NPCM_SMBCTL4);
+	iowrite8(hldt, bus->reg + NPCM_SMBCTL4);
 
 	// Return to Bank 1, and stay there by default:
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
-	dev_dbg(bus->dev, "k1 = %d k2 = %d dbnct = %d sclfrq = %d hldt = %d src_clk_freq %d fast_mode %d\n",
-		k1, k2, dbnct, sclfrq, hldt, src_clk_freq, fast_mode);
-
 	return true;
 }
 
@@ -1614,20 +2013,25 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 	if ((bus->state != SMB_DISABLE && bus->state != SMB_IDLE) ||
 	    bus_freq < SMBUS_FREQ_MIN || bus_freq > SMBUS_FREQ_MAX)
 		return false;
-	// Configure FIFO disabled mode so slave will not use fifo
-	// (maste will set it on if supported)
-	bus->threshold_fifo = SMBUS_FIFO_SIZE;
-	iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) & ~NPCM_SMBFIF_CTL_FIFO_EN,
-		 bus->reg + NPCM_SMBFIF_CTL);
 
-	bus->fifo_use = false;
+	npcm_smb_disable(bus);
+
+	// Configure FIFO mode :
+	if (FIELD_GET(SMB_VER_FIFO_EN, ioread8(bus->reg + SMB_VER))) {
+		bus->fifo_use = true;
+		npcm_smb_select_bank(bus, SMB_BANK_0);
+		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) |
+			 NPCM_SMBFIF_CTL_FIFO_EN, bus->reg + NPCM_SMBFIF_CTL);
+		npcm_smb_select_bank(bus, SMB_BANK_1);
+	} else {
+		bus->fifo_use = false;
+	}
 
 	// Configure SMB module clock frequency
-	if (!npcm_smb_init_clk(bus, mode, bus_freq)) {
-		pr_err("npcm_smb_init_clk failed\n");
+	if (!npcm_smb_init_clk(bus, bus_freq)) {
+		dev_err(bus->dev, "npcm_smb_init_clk failed\n");
 		return false;
 	}
-	npcm_smb_disable(bus);
 
 	// Enable module (before configuring CTL1)
 	npcm_smb_enable(bus);
@@ -1639,6 +2043,9 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 		 bus->reg + NPCM_SMBCTL1);
 
 	npcm_smb_int_enable(bus, true);
+
+	npcm_smb_reset(bus);
+
 	return true;
 }
 
@@ -1650,14 +2057,17 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 	// Initialize the internal data structures
 	bus->state = SMB_DISABLE;
 	bus->master_or_slave = SMB_SLAVE;
+	bus->int_time_stamp = 0;
+	bus->slave = NULL;
+	bus->xmits = 0;
 
 	ret = of_property_read_u32(pdev->dev.of_node,
 				   "bus-frequency", &clk_freq);
 	if (ret < 0) {
-		dev_err(&pdev->dev,
-			"Could not read bus-frequency property\n");
+		dev_err(&pdev->dev, "Could not read bus-frequency property\n");
 		clk_freq = 100000;
 	}
+
 	ret = npcm_smb_init_module(bus, SMB_MASTER, clk_freq / 1000);
 	if (!ret) {
 		dev_err(&pdev->dev,
@@ -1665,59 +2075,47 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 		return -1;
 	}
 
-	crc8_populate_lsb(npcm7xx_crc8, 0x07);
-	crc8_populate_msb(npcm7xx_crc8, 0x07);
 	return 0;
 }
 
 static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id)
 {
+	irqreturn_t ret;
 	struct npcm_i2c *bus = dev_id;
 
 	bus->int_cnt++;
-	_npcm7xx_get_time_stamp(&bus->int_time_stamp[0],
-				&bus->int_time_stamp[1]);
+
+	if (npcm_smb_is_master(bus))
+		bus->master_or_slave = SMB_MASTER;
+
 	if (bus->master_or_slave == SMB_MASTER)	{
-		npcm_smb_int_master_handler(bus);
-		return IRQ_HANDLED;
+		bus->int_time_stamp = jiffies;
+		ret = npcm_smb_int_master_handler(bus);
+		if (ret == IRQ_HANDLED)
+			return ret;
 	}
-
-	dev_err(bus->dev, "int unknown on bus%d\n", bus->num);
-	return IRQ_NONE;
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	if (bus->slave) {
+		bus->master_or_slave = SMB_SLAVE;
+		ret = npcm_smb_int_slave_handler(bus);
+		if (ret == IRQ_HANDLED)
+			return ret;
+	}
+#endif
+	return IRQ_HANDLED;
 }
 
 static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 				       u8 slave_addr, u16 nwrite, u16 nread,
 				       u8 *write_data, u8 *read_data,
-				       bool use_PEC)
+				       bool use_PEC, bool use_read_block)
 {
-	//
-	// Allow only if bus is not busy
-	//
 	if (bus->state != SMB_IDLE) {
-		dev_info(bus->dev, "\tbus%d->state != SMB_IDLE\n", bus->num);
+		bus->cmd_err = -(EBUSY);
 		return false;
 	}
 
-	// Configure FIFO mode :
-	if (FIELD_GET(SMB_VER_FIFO_EN, ioread8(bus->reg + SMB_VER))) {
-		bus->fifo_use = true;
-		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) |
-			 NPCM_SMBFIF_CTL_FIFO_EN, bus->reg + NPCM_SMBFIF_CTL);
-	} else {
-		bus->fifo_use = false;
-	}
-
-	// Update driver state
-	bus->master_or_slave = SMB_MASTER;
-	bus->state = SMB_MASTER_START;
-	if (nwrite > 0)
-		bus->operation = SMB_WRITE_OPER;
-	else
-		bus->operation = SMB_READ_OPER;
-
-	if (npcm_smb_is_quick(bus))
-		bus->operation = SMB_WRITE_OPER; // send the address with W bit.
+	bus->xmits++;
 
 	bus->dest_addr = (u8)(slave_addr << 1);// Translate 7bit to 8bit format
 	bus->wr_buf = write_data;
@@ -1726,35 +2124,36 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 	bus->rd_buf = read_data;
 	bus->rd_size = nread;
 	bus->rd_ind = 0;
-	bus->PEC_use = use_PEC;
-	bus->retry_count = SMB_RETRY_MAX_COUNT;
+	bus->PEC_use = 0;
+
+	// for write, PEC is appended to buffer from i2c IF. PEC flag is ignored
+	if (nread)
+		bus->PEC_use = use_PEC;
+	bus->read_block_use = use_read_block;
+	if (nread && !nwrite)
+		bus->operation = SMB_READ_OPER;
+	else
+		bus->operation = SMB_WRITE_OPER;
 
-	// clear BER just in case it is set due to a previous transaction
-	iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
+	bus->int_cnt = 0;
+	bus->event_log = 0;
 
-	// Initiate SMBus master transaction
-	// Generate a Start condition on the SMBus
 	if (bus->fifo_use) {
+		u8 smbfif_cts;
 		// select bank 1 for FIFO regs
 		npcm_smb_select_bank(bus, SMB_BANK_1);
 
-		// clear FIFO and relevant status bits.
-		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTS) |
-			 NPCM_SMBFIF_CTS_SLVRSTR |
-			 NPCM_SMBFIF_CTS_CLR_FIFO |
-			 NPCM_SMBFIF_CTS_RXF_TXE, bus->reg + NPCM_SMBFIF_CTS);
+		smbfif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
 
-		if (bus->operation == SMB_READ_OPER) {
-			//This is a read only operation. Configure the FIFO
-			//threshold according to the needed # of bytes to read.
-			npcm_smb_set_fifo(bus, nread, -1);
-		} else if (bus->operation == SMB_WRITE_OPER) {
-			npcm_smb_set_fifo(bus, -1, nwrite);
-		}
+		// clear FIFO and relevant status bits.
+		iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
+			 NPCM_SMBFIF_CTS_CLR_FIFO,
+			 bus->reg + NPCM_SMBFIF_CTS);
 	}
 
-	bus->int_cnt = 0;
-	bus->event_log = 0;
+	bus->state = SMB_IDLE;
+
+	npcm_smb_stall_after_start(bus, true);
 	npcm_smb_master_start(bus);
 
 	return true;
@@ -1763,25 +2162,26 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 				int num)
 {
-	struct npcm_i2c *bus = adap->algo_data;
+	struct npcm_i2c *bus = container_of(adap, struct npcm_i2c, adap);
 	struct i2c_msg *msg0, *msg1;
 	unsigned long time_left, flags;
 	u16 nwrite, nread;
 	u8 *write_data, *read_data;
 	u8 slave_addr;
+	int timeout;
 	int ret = 0;
+	bool read_block = false;
+	bool read_PEC = false;
+	u8 bus_busy;
+	unsigned long timeout_usec;
 
-	spin_lock_irqsave(&bus->lock, flags);
-	bus->cmd_err = -EPERM;
-	bus->int_cnt = 0;
-	bus->stop_ind = SMB_NO_STATUS_IND;
-	bus->read_block_use = false;
-
-	iowrite8(0xFF, bus->reg + NPCM_SMBST);
+	if (unlikely(bus->state == SMB_DISABLE)) {
+		dev_err(bus->dev, "I2C%d module is disabled", bus->num);
+		return -EINVAL;
+	}
 
 	if (num > 2 || num < 1) {
-		pr_err("I2C command not supported, num of msgs = %d\n", num);
-		spin_unlock_irqrestore(&bus->lock, flags);
+		dev_err(bus->dev, "I2C cmd not supported num of msgs=%d", num);
 		return -EINVAL;
 	}
 
@@ -1789,21 +2189,20 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	slave_addr = msg0->addr;
 	if (msg0->flags & I2C_M_RD) { // read
 		if (num == 2) {
-			pr_err(" num = 2 but first msg is rd instead of wr\n");
-			spin_unlock_irqrestore(&bus->lock, flags);
+			dev_err(bus->dev, "num=2 but 1st msg rd instead of wr");
 			return -EINVAL;
 		}
 		nwrite = 0;
 		write_data = NULL;
+		read_data = msg0->buf;
 		if (msg0->flags & I2C_M_RECV_LEN) {
 			nread = 1;
-			bus->read_block_use = true;
-
+			read_block = true;
+			if (msg0->flags & I2C_CLIENT_PEC)
+				read_PEC = true;
 		} else {
 			nread = msg0->len;
 		}
-		read_data = msg0->buf;
-
 	} else { // write
 		nwrite = msg0->len;
 		write_data = msg0->buf;
@@ -1811,86 +2210,140 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 		read_data = NULL;
 		if (num == 2) {
 			msg1 = &msgs[1];
+			read_data = msg1->buf;
 			if (slave_addr != msg1->addr) {
-				pr_err("SA==%02x but msg1->addr == %02x\n",
+				dev_err(bus->dev,
+					"SA==%02x but msg1->addr==%02x\n",
 				       slave_addr, msg1->addr);
-				spin_unlock_irqrestore(&bus->lock, flags);
 				return -EINVAL;
 			}
 			if ((msg1->flags & I2C_M_RD) == 0) {
-				pr_err("num = 2 but both msg are write.\n");
-				spin_unlock_irqrestore(&bus->lock, flags);
+				dev_err(bus->dev,
+					"num = 2 but both msg are write.\n");
 				return -EINVAL;
 			}
 			if (msg1->flags & I2C_M_RECV_LEN) {
 				nread = 1;
-				bus->read_block_use = true;
+				read_block = true;
+				if (msg1->flags & I2C_CLIENT_PEC)
+					read_PEC = true;
 			} else {
 				nread = msg1->len;
-				bus->read_block_use = false;
+				read_block = false;
 			}
-
-			read_data = msg1->buf;
 		}
 	}
 
-	bus->msgs = msgs;
-	bus->msgs_num = num;
-
+	/* Adaptive TimeOut: astimated time in usec  + 100% margin */
+	timeout_usec = (2 * 10000 / bus->bus_freq) * (2 + nread + nwrite);
+	timeout = max(msecs_to_jiffies(35), usecs_to_jiffies(timeout_usec));
 	if (nwrite >= 32 * 1024 ||  nread >= 32 * 1024) {
-		pr_err("i2c%d buffer too big\n", bus->num);
+		dev_err(bus->dev, "i2c%d buffer too big\n", bus->num);
 		return -EINVAL;
 	}
 
+	time_left = jiffies +
+		    msecs_to_jiffies(DEFAULT_STALL_COUNT) + 1;
+	do {
+		/* we must clear slave address immediately when the bus is not
+		 * busy, so we spinlock it, but we don't keep the lock for the
+		 * entire while since it is too long.
+		 */
+		spin_lock_irqsave(&bus->lock, flags);
+		bus_busy = ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB;
+		if (!bus_busy && bus->slave)
+			iowrite8((bus->slave->addr & 0x7F),
+				 bus->reg + NPCM_SMBADDR1);
+		spin_unlock_irqrestore(&bus->lock, flags);
+
+		if (!bus_busy)
+			break;
+	} while (time_is_after_jiffies(time_left));
+
+	if (bus_busy) {
+		iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
+		npcm_smb_reset(bus);
+		i2c_recover_bus(adap);
+		return -EAGAIN;
+	}
+
+	npcm_smb_init_params(bus);
+	bus->dest_addr = slave_addr;
+	bus->msgs = msgs;
+	bus->msgs_num = num;
+	bus->read_block_use = read_block;
+
 	reinit_completion(&bus->cmd_complete);
 
-	if (npcm_smb_master_start_xmit(bus, slave_addr, nwrite, nread,
-				       write_data, read_data, 0) == false)
+	if (!npcm_smb_master_start_xmit(bus, slave_addr, nwrite, nread,
+					write_data, read_data, read_PEC,
+					read_block))
 		ret = -(EBUSY);
 
 	if (ret != -(EBUSY)) {
 		time_left = wait_for_completion_timeout(&bus->cmd_complete,
-							bus->adap.timeout);
-
-		if (time_left == 0 && bus->cmd_err == -EPERM) {
-			npcm_smb_master_abort(bus);
-			ret = -ETIMEDOUT;
-		} else {
-			ret = bus->cmd_err;
+							timeout);
+
+		if (time_left == 0) {
+			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_TO);
+			if (bus->master_or_slave == SMB_MASTER) {
+				dev_dbg(bus->dev,
+					"i2c%d TO = %d\n", bus->num, timeout);
+				i2c_recover_bus(adap);
+				bus->cmd_err = -EIO;
+				bus->state = SMB_IDLE;
+			}
 		}
 	}
+	ret = bus->cmd_err;
+
+	// if there was BER, check if need to recover the bus:
+	if (bus->cmd_err == -EAGAIN)
+		i2c_recover_bus(adap);
 
-	bus->msgs = NULL;
-	bus->msgs_num = 0;
-	spin_unlock_irqrestore(&bus->lock, flags);
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	// reenable slave if it was enabled
+	if (bus->slave)
+		iowrite8((bus->slave->addr & 0x7F) | NPCM_SMBADDR_SAEN,
+			 bus->reg + NPCM_SMBADDR1);
+#endif
 
-	// If nothing went wrong, return number of messages xferred.
+	// If nothing went wrong, return number of messages x-ferred.
 	if (ret >= 0)
 		return num;
-	else
-		return ret;
+
+	// print errors apart from NACK
+	if (bus->cmd_err == -ENXIO)
+		dev_dbg(bus->dev, "cmd failed cmd_err = %d\n", ret);
+	return ret;
 }
 
 static u32 npcm_i2c_functionality(struct i2c_adapter *adap)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA |
+			I2C_FUNC_SLAVE | I2C_FUNC_SMBUS_PEC;
 }
 
+static const struct i2c_adapter_quirks npcm_i2c_quirks = {
+	.max_read_len = 32768,
+	.max_write_len = 32768,
+	.max_num_msgs = 2,
+	.flags = I2C_AQ_COMB_WRITE_THEN_READ
+};
+
 static const struct i2c_algorithm npcm_i2c_algo = {
 	.master_xfer = npcm_i2c_master_xfer,
 	.functionality = npcm_i2c_functionality,
-};
-
-static struct i2c_bus_recovery_info npcm_i2c_recovery = {
-	.recover_bus = npcm_smb_recovery,
-	.get_scl = npcm_smb_get_SCL,
-	.set_scl = npcm_smb_set_SCL,
-	.get_sda = npcm_smb_get_SDA,
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	.reg_slave	= npcm_i2c_reg_slave,
+	.unreg_slave	= npcm_i2c_unreg_slave,
+#endif
 };
 
 static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 {
 	struct npcm_i2c *bus;
+	struct i2c_adapter *adap;
 	struct resource *res;
 	struct clk *i2c_clk;
 	int ret;
@@ -1905,7 +2358,7 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 	bus->num = num;
 	i2c_clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(i2c_clk)) {
-		pr_err(" I2C probe failed: can't read clk.\n");
+		dev_err(bus->dev, " I2C probe failed: can't read clk\n");
 		return	-EPROBE_DEFER;
 	}
 	bus->apb_clk = clk_get_rate(i2c_clk);
@@ -1914,7 +2367,8 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 
 	gcr_regmap = syscon_regmap_lookup_by_compatible("nuvoton,npcm750-gcr");
 	if (IS_ERR(gcr_regmap)) {
-		pr_err("%s: failed to find nuvoton,npcm750-gcr\n", __func__);
+		dev_err(bus->dev, "%s: failed to find nuvoton,npcm750-gcr\n",
+			__func__);
 		return IS_ERR(gcr_regmap);
 	}
 	regmap_write(gcr_regmap, NPCM_I2CSEGCTL, I2CSEGCTL_VAL);
@@ -1922,7 +2376,8 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 
 	clk_regmap = syscon_regmap_lookup_by_compatible("nuvoton,npcm750-clk");
 	if (IS_ERR(clk_regmap)) {
-		pr_err("%s: failed to find nuvoton,npcm750-clk\n", __func__);
+		dev_err(bus->dev, "%s: failed to find nuvoton,npcm750-clk\n",
+			__func__);
 		return IS_ERR(clk_regmap);
 	}
 	dev_dbg(bus->dev, "I2C%d: clk mapped\n", bus->num);
@@ -1937,46 +2392,59 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 	// Initialize the I2C adapter
 	spin_lock_init(&bus->lock);
 	init_completion(&bus->cmd_complete);
-	bus->adap.owner = THIS_MODULE;
-	bus->adap.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
-	bus->adap.retries = 0;
-	bus->adap.timeout = 500 * HZ / 1000;
-	bus->adap.algo = &npcm_i2c_algo;
-	bus->adap.algo_data = bus;
-	bus->adap.dev.parent = &pdev->dev;
-	bus->adap.dev.of_node = pdev->dev.of_node;
-	bus->adap.bus_recovery_info = &npcm_i2c_recovery;
 
-	snprintf(bus->adap.name, sizeof(bus->adap.name), "Nuvoton i2c");
+	adap = &bus->adap;
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD | I2C_CLIENT_SLAVE;
+	adap->retries = 3;
+	adap->timeout = HZ;
+	adap->algo = &npcm_i2c_algo;
+	adap->quirks = &npcm_i2c_quirks;
+	adap->algo_data = bus;
+	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
+	adap->nr = pdev->id;
 
 	bus->dev = &pdev->dev;
-
-	ret = __npcm_i2c_init(bus, pdev);
-	if (ret < 0)
-		return ret;
+	bus->slave = NULL;
 
 	bus->irq = platform_get_irq(pdev, 0);
 	if (bus->irq < 0) {
-		pr_err("I2C platform_get_irq error.");
+		dev_err(bus->dev, "I2C platform_get_irq error\n");
 		return -ENODEV;
 	}
 	dev_dbg(bus->dev, "irq = %d\n", bus->irq);
 
-	ret = request_irq(bus->irq, npcm_i2c_bus_irq, 0,
-			  dev_name(&pdev->dev), (void *)bus);
+	ret = devm_request_irq(&pdev->dev, bus->irq, npcm_i2c_bus_irq, 0,
+			       dev_name(&pdev->dev), (void *)bus);
+
 	if (ret) {
 		dev_err(&pdev->dev, "I2C%d: request_irq fail\n", bus->num);
 		return ret;
 	}
 
-	ret = i2c_add_adapter(&bus->adap);
+	ret = __npcm_i2c_init(bus, pdev);
+	if (ret < 0)
+		return ret;
+
+	ret = npcm_smb_recovery_init(adap);
+	if (ret)
+		return ret;
+
+	i2c_set_adapdata(adap, bus);
+
+	snprintf(bus->adap.name, sizeof(bus->adap.name), "Nuvoton i2c");
+
+	ret = i2c_add_numbered_adapter(&bus->adap);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "I2C%d: i2c_add_adapter fail\n", bus->num);
+		dev_err(&pdev->dev, "I2C%d: i2c_add_numbered_adapter fail\n",
+			bus->num);
 		return ret;
 	}
 
 	platform_set_drvdata(pdev, bus);
-	pr_info("i2c bus %d registered\n", bus->adap.nr);
+
+	pr_info("npcm7xx I2C bus is %d registered\n", bus->adap.nr);
 
 	return 0;
 }
@@ -2012,6 +2480,7 @@ module_platform_driver(npcm_i2c_bus_driver);
 
 MODULE_AUTHOR("Avi Fishman <avi.fishman@gmail.com>");
 MODULE_AUTHOR("Tali Perry <tali.perry@nuvoton.com>");
+MODULE_AUTHOR("Tyrone Ting <kfting@nuvoton.com>");
 MODULE_DESCRIPTION("Nuvoton I2C Bus Driver");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(I2C_VERSION);
-- 
2.17.1

