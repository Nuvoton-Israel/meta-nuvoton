From 0d92d9968ccd17172b98a7bb899f6cd1bab22a41 Mon Sep 17 00:00:00 2001
From: Joseph Liu <kwliu@nuvoton.com>
Date: Fri, 20 Dec 2019 15:19:49 +0800
Subject: [PATCH 28/34] npcm: jtag master: assign jtag device number in dts

Signed-off-by: Joseph Liu <kwliu@nuvoton.com>
---
 arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts |  1 +
 drivers/misc/nuvoton-jtag/jtag_drv.c                 | 12 ++++++++++--
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts b/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
index 4eadaa41a3d3..e328a8bd6aaa 100644
--- a/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
@@ -67,6 +67,7 @@
 		#address-cells = <1>;
 		#size-cells = <1>;
 
+		dev-num = <0>;
 		pspi-controller = <2>; /* pspi2 */
 		reg = <0xf0201000 0x1000>;
 		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
diff --git a/drivers/misc/nuvoton-jtag/jtag_drv.c b/drivers/misc/nuvoton-jtag/jtag_drv.c
index 4af5f02f3212..bfc928bd54bf 100644
--- a/drivers/misc/nuvoton-jtag/jtag_drv.c
+++ b/drivers/misc/nuvoton-jtag/jtag_drv.c
@@ -106,6 +106,7 @@ struct jtag_info {
 	struct regmap		*gcr_regmap;
 	u32 freq;
 	u32 controller; /* PSPI controller */
+	u32 dev_num;
 	u8 tms_level;
 	u8 tapstate;
 	bool is_open;
@@ -1048,7 +1049,6 @@ const struct file_operations npcm_jtag_fops = {
 static int jtag_register_device(struct jtag_info *jtag)
 {
 	struct device *dev = jtag->dev;
-	static int dev_num = 0;
 	int err;
 
 	if (!dev)
@@ -1058,7 +1058,7 @@ static int jtag_register_device(struct jtag_info *jtag)
 	jtag->miscdev.parent = dev;
 	jtag->miscdev.fops =  &npcm_jtag_fops;
 	jtag->miscdev.minor = MISC_DYNAMIC_MINOR;
-	jtag->miscdev.name = kasprintf(GFP_KERNEL, "jtag%d", dev_num++);
+	jtag->miscdev.name = kasprintf(GFP_KERNEL, "jtag%d", jtag->dev_num);
 	if (!jtag->miscdev.name)
 		return -ENOMEM;
 
@@ -1203,6 +1203,14 @@ static int npcm_jtag_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev,
 				"Could not read pspi index\n");
 	npcm_jtag->controller = value;
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+			"dev-num", &value);
+	if (ret < 0 || (value != PSPI1 && value != PSPI2))
+		dev_err(&pdev->dev,
+				"Could not read dev_num\n");
+	npcm_jtag->dev_num = value;
+
 	npcm_jtag_pspi_probe(pdev, &npcm_jtag->pspi);
 
 	npcm_jtag_init(npcm_jtag);
-- 
2.17.1

